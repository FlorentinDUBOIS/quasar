// This file is generated by rust-protobuf 2.4.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Schema {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    schema_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    field_type: ::std::option::Option<Schema_Type>,
    properties: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Schema {
    pub fn new() -> Schema {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bytes schema_data = 3;

    pub fn clear_schema_data(&mut self) {
        self.schema_data.clear();
    }

    pub fn has_schema_data(&self) -> bool {
        self.schema_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_data.is_none() {
            self.schema_data.set_default();
        }
        self.schema_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_data(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema_data(&self) -> &[u8] {
        match self.schema_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // required .pulsar.proto.Schema.Type type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Schema_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> Schema_Type {
        self.field_type.unwrap_or(Schema_Type::None)
    }

    // repeated .pulsar.proto.KeyValue properties = 5;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }
}

impl ::protobuf::Message for Schema {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.schema_data.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_data)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.schema_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.schema_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(4, v.value())?;
        }
        for v in &self.properties {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Schema {
        Schema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Schema| { &m.name },
                    |m: &mut Schema| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "schema_data",
                    |m: &Schema| { &m.schema_data },
                    |m: &mut Schema| { &mut m.schema_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Schema_Type>>(
                    "type",
                    |m: &Schema| { &m.field_type },
                    |m: &mut Schema| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "properties",
                    |m: &Schema| { &m.properties },
                    |m: &mut Schema| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Schema>(
                    "Schema",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Schema {
        static mut instance: ::protobuf::lazy::Lazy<Schema> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Schema,
        };
        unsafe {
            instance.get(Schema::new)
        }
    }
}

impl ::protobuf::Clear for Schema {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_schema_data();
        self.clear_field_type();
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Schema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Schema {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Schema_Type {
    None = 0,
    String = 1,
    Json = 2,
    Protobuf = 3,
    Avro = 4,
    Bool = 5,
    Int8 = 6,
    Int16 = 7,
    Int32 = 8,
    Int64 = 9,
    Float = 10,
    Double = 11,
    Date = 12,
    Time = 13,
    Timestamp = 14,
    KeyValue = 15,
}

impl ::protobuf::ProtobufEnum for Schema_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Schema_Type> {
        match value {
            0 => ::std::option::Option::Some(Schema_Type::None),
            1 => ::std::option::Option::Some(Schema_Type::String),
            2 => ::std::option::Option::Some(Schema_Type::Json),
            3 => ::std::option::Option::Some(Schema_Type::Protobuf),
            4 => ::std::option::Option::Some(Schema_Type::Avro),
            5 => ::std::option::Option::Some(Schema_Type::Bool),
            6 => ::std::option::Option::Some(Schema_Type::Int8),
            7 => ::std::option::Option::Some(Schema_Type::Int16),
            8 => ::std::option::Option::Some(Schema_Type::Int32),
            9 => ::std::option::Option::Some(Schema_Type::Int64),
            10 => ::std::option::Option::Some(Schema_Type::Float),
            11 => ::std::option::Option::Some(Schema_Type::Double),
            12 => ::std::option::Option::Some(Schema_Type::Date),
            13 => ::std::option::Option::Some(Schema_Type::Time),
            14 => ::std::option::Option::Some(Schema_Type::Timestamp),
            15 => ::std::option::Option::Some(Schema_Type::KeyValue),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Schema_Type] = &[
            Schema_Type::None,
            Schema_Type::String,
            Schema_Type::Json,
            Schema_Type::Protobuf,
            Schema_Type::Avro,
            Schema_Type::Bool,
            Schema_Type::Int8,
            Schema_Type::Int16,
            Schema_Type::Int32,
            Schema_Type::Int64,
            Schema_Type::Float,
            Schema_Type::Double,
            Schema_Type::Date,
            Schema_Type::Time,
            Schema_Type::Timestamp,
            Schema_Type::KeyValue,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Schema_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Schema_Type {
}

impl ::std::default::Default for Schema_Type {
    fn default() -> Self {
        Schema_Type::None
    }
}

impl ::protobuf::reflect::ProtobufValue for Schema_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageIdData {
    // message fields
    ledgerId: ::std::option::Option<u64>,
    entryId: ::std::option::Option<u64>,
    partition: ::std::option::Option<i32>,
    batch_index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageIdData {
    pub fn new() -> MessageIdData {
        ::std::default::Default::default()
    }

    // required uint64 ledgerId = 1;

    pub fn clear_ledgerId(&mut self) {
        self.ledgerId = ::std::option::Option::None;
    }

    pub fn has_ledgerId(&self) -> bool {
        self.ledgerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledgerId(&mut self, v: u64) {
        self.ledgerId = ::std::option::Option::Some(v);
    }

    pub fn get_ledgerId(&self) -> u64 {
        self.ledgerId.unwrap_or(0)
    }

    // required uint64 entryId = 2;

    pub fn clear_entryId(&mut self) {
        self.entryId = ::std::option::Option::None;
    }

    pub fn has_entryId(&self) -> bool {
        self.entryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryId(&mut self, v: u64) {
        self.entryId = ::std::option::Option::Some(v);
    }

    pub fn get_entryId(&self) -> u64 {
        self.entryId.unwrap_or(0)
    }

    // optional int32 partition = 3;

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(-1i32)
    }

    // optional int32 batch_index = 4;

    pub fn clear_batch_index(&mut self) {
        self.batch_index = ::std::option::Option::None;
    }

    pub fn has_batch_index(&self) -> bool {
        self.batch_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_batch_index(&mut self, v: i32) {
        self.batch_index = ::std::option::Option::Some(v);
    }

    pub fn get_batch_index(&self) -> i32 {
        self.batch_index.unwrap_or(-1i32)
    }
}

impl ::protobuf::Message for MessageIdData {
    fn is_initialized(&self) -> bool {
        if self.ledgerId.is_none() {
            return false;
        }
        if self.entryId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ledgerId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.entryId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.batch_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ledgerId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entryId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.batch_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ledgerId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.entryId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.batch_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageIdData {
        MessageIdData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ledgerId",
                    |m: &MessageIdData| { &m.ledgerId },
                    |m: &mut MessageIdData| { &mut m.ledgerId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "entryId",
                    |m: &MessageIdData| { &m.entryId },
                    |m: &mut MessageIdData| { &mut m.entryId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partition",
                    |m: &MessageIdData| { &m.partition },
                    |m: &mut MessageIdData| { &mut m.partition },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "batch_index",
                    |m: &MessageIdData| { &m.batch_index },
                    |m: &mut MessageIdData| { &mut m.batch_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageIdData>(
                    "MessageIdData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageIdData {
        static mut instance: ::protobuf::lazy::Lazy<MessageIdData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageIdData,
        };
        unsafe {
            instance.get(MessageIdData::new)
        }
    }
}

impl ::protobuf::Clear for MessageIdData {
    fn clear(&mut self) {
        self.clear_ledgerId();
        self.clear_entryId();
        self.clear_partition();
        self.clear_batch_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageIdData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageIdData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValue {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for KeyValue {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &KeyValue| { &m.key },
                    |m: &mut KeyValue| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &KeyValue| { &m.value },
                    |m: &mut KeyValue| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyValue>(
                    "KeyValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyValue {
        static mut instance: ::protobuf::lazy::Lazy<KeyValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyValue,
        };
        unsafe {
            instance.get(KeyValue::new)
        }
    }
}

impl ::protobuf::Clear for KeyValue {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyLongValue {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyLongValue {
    pub fn new() -> KeyLongValue {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 value = 2;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value(&self) -> u64 {
        self.value.unwrap_or(0)
    }
}

impl ::protobuf::Message for KeyLongValue {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyLongValue {
        KeyLongValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &KeyLongValue| { &m.key },
                    |m: &mut KeyLongValue| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "value",
                    |m: &KeyLongValue| { &m.value },
                    |m: &mut KeyLongValue| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyLongValue>(
                    "KeyLongValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyLongValue {
        static mut instance: ::protobuf::lazy::Lazy<KeyLongValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyLongValue,
        };
        unsafe {
            instance.get(KeyLongValue::new)
        }
    }
}

impl ::protobuf::Clear for KeyLongValue {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyLongValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyLongValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptionKeys {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    metadata: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncryptionKeys {
    pub fn new() -> EncryptionKeys {
        ::std::default::Default::default()
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required bytes value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        self.value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        match self.value.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .pulsar.proto.KeyValue metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }
}

impl ::protobuf::Message for EncryptionKeys {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.metadata {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionKeys {
        EncryptionKeys::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &EncryptionKeys| { &m.key },
                    |m: &mut EncryptionKeys| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &EncryptionKeys| { &m.value },
                    |m: &mut EncryptionKeys| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "metadata",
                    |m: &EncryptionKeys| { &m.metadata },
                    |m: &mut EncryptionKeys| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncryptionKeys>(
                    "EncryptionKeys",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptionKeys {
        static mut instance: ::protobuf::lazy::Lazy<EncryptionKeys> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncryptionKeys,
        };
        unsafe {
            instance.get(EncryptionKeys::new)
        }
    }
}

impl ::protobuf::Clear for EncryptionKeys {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionKeys {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageMetadata {
    // message fields
    producer_name: ::protobuf::SingularField<::std::string::String>,
    sequence_id: ::std::option::Option<u64>,
    publish_time: ::std::option::Option<u64>,
    properties: ::protobuf::RepeatedField<KeyValue>,
    replicated_from: ::protobuf::SingularField<::std::string::String>,
    partition_key: ::protobuf::SingularField<::std::string::String>,
    replicate_to: ::protobuf::RepeatedField<::std::string::String>,
    compression: ::std::option::Option<CompressionType>,
    uncompressed_size: ::std::option::Option<u32>,
    num_messages_in_batch: ::std::option::Option<i32>,
    event_time: ::std::option::Option<u64>,
    encryption_keys: ::protobuf::RepeatedField<EncryptionKeys>,
    encryption_algo: ::protobuf::SingularField<::std::string::String>,
    encryption_param: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    partition_key_b64_encoded: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageMetadata {
    pub fn new() -> MessageMetadata {
        ::std::default::Default::default()
    }

    // required string producer_name = 1;

    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 sequence_id = 2;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }

    // required uint64 publish_time = 3;

    pub fn clear_publish_time(&mut self) {
        self.publish_time = ::std::option::Option::None;
    }

    pub fn has_publish_time(&self) -> bool {
        self.publish_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish_time(&mut self, v: u64) {
        self.publish_time = ::std::option::Option::Some(v);
    }

    pub fn get_publish_time(&self) -> u64 {
        self.publish_time.unwrap_or(0)
    }

    // repeated .pulsar.proto.KeyValue properties = 4;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }

    // optional string replicated_from = 5;

    pub fn clear_replicated_from(&mut self) {
        self.replicated_from.clear();
    }

    pub fn has_replicated_from(&self) -> bool {
        self.replicated_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicated_from(&mut self, v: ::std::string::String) {
        self.replicated_from = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicated_from(&mut self) -> &mut ::std::string::String {
        if self.replicated_from.is_none() {
            self.replicated_from.set_default();
        }
        self.replicated_from.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicated_from(&mut self) -> ::std::string::String {
        self.replicated_from.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_replicated_from(&self) -> &str {
        match self.replicated_from.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string partition_key = 6;

    pub fn clear_partition_key(&mut self) {
        self.partition_key.clear();
    }

    pub fn has_partition_key(&self) -> bool {
        self.partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: ::std::string::String) {
        self.partition_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key(&mut self) -> &mut ::std::string::String {
        if self.partition_key.is_none() {
            self.partition_key.set_default();
        }
        self.partition_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key(&mut self) -> ::std::string::String {
        self.partition_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_partition_key(&self) -> &str {
        match self.partition_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string replicate_to = 7;

    pub fn clear_replicate_to(&mut self) {
        self.replicate_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicate_to(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.replicate_to = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicate_to(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.replicate_to
    }

    // Take field
    pub fn take_replicate_to(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.replicate_to, ::protobuf::RepeatedField::new())
    }

    pub fn get_replicate_to(&self) -> &[::std::string::String] {
        &self.replicate_to
    }

    // optional .pulsar.proto.CompressionType compression = 8;

    pub fn clear_compression(&mut self) {
        self.compression = ::std::option::Option::None;
    }

    pub fn has_compression(&self) -> bool {
        self.compression.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compression(&mut self, v: CompressionType) {
        self.compression = ::std::option::Option::Some(v);
    }

    pub fn get_compression(&self) -> CompressionType {
        self.compression.unwrap_or(CompressionType::NONE)
    }

    // optional uint32 uncompressed_size = 9;

    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = ::std::option::Option::None;
    }

    pub fn has_uncompressed_size(&self) -> bool {
        self.uncompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: u32) {
        self.uncompressed_size = ::std::option::Option::Some(v);
    }

    pub fn get_uncompressed_size(&self) -> u32 {
        self.uncompressed_size.unwrap_or(0u32)
    }

    // optional int32 num_messages_in_batch = 11;

    pub fn clear_num_messages_in_batch(&mut self) {
        self.num_messages_in_batch = ::std::option::Option::None;
    }

    pub fn has_num_messages_in_batch(&self) -> bool {
        self.num_messages_in_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages_in_batch(&mut self, v: i32) {
        self.num_messages_in_batch = ::std::option::Option::Some(v);
    }

    pub fn get_num_messages_in_batch(&self) -> i32 {
        self.num_messages_in_batch.unwrap_or(1i32)
    }

    // optional uint64 event_time = 12;

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u64) {
        self.event_time = ::std::option::Option::Some(v);
    }

    pub fn get_event_time(&self) -> u64 {
        self.event_time.unwrap_or(0u64)
    }

    // repeated .pulsar.proto.EncryptionKeys encryption_keys = 13;

    pub fn clear_encryption_keys(&mut self) {
        self.encryption_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryption_keys(&mut self, v: ::protobuf::RepeatedField<EncryptionKeys>) {
        self.encryption_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryption_keys(&mut self) -> &mut ::protobuf::RepeatedField<EncryptionKeys> {
        &mut self.encryption_keys
    }

    // Take field
    pub fn take_encryption_keys(&mut self) -> ::protobuf::RepeatedField<EncryptionKeys> {
        ::std::mem::replace(&mut self.encryption_keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_encryption_keys(&self) -> &[EncryptionKeys] {
        &self.encryption_keys
    }

    // optional string encryption_algo = 14;

    pub fn clear_encryption_algo(&mut self) {
        self.encryption_algo.clear();
    }

    pub fn has_encryption_algo(&self) -> bool {
        self.encryption_algo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_algo(&mut self, v: ::std::string::String) {
        self.encryption_algo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_algo(&mut self) -> &mut ::std::string::String {
        if self.encryption_algo.is_none() {
            self.encryption_algo.set_default();
        }
        self.encryption_algo.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_algo(&mut self) -> ::std::string::String {
        self.encryption_algo.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_encryption_algo(&self) -> &str {
        match self.encryption_algo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes encryption_param = 15;

    pub fn clear_encryption_param(&mut self) {
        self.encryption_param.clear();
    }

    pub fn has_encryption_param(&self) -> bool {
        self.encryption_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_param(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryption_param = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryption_param(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryption_param.is_none() {
            self.encryption_param.set_default();
        }
        self.encryption_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryption_param(&mut self) -> ::std::vec::Vec<u8> {
        self.encryption_param.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_encryption_param(&self) -> &[u8] {
        match self.encryption_param.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes schema_version = 16;

    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool partition_key_b64_encoded = 17;

    pub fn clear_partition_key_b64_encoded(&mut self) {
        self.partition_key_b64_encoded = ::std::option::Option::None;
    }

    pub fn has_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_b64_encoded(&mut self, v: bool) {
        self.partition_key_b64_encoded = ::std::option::Option::Some(v);
    }

    pub fn get_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.unwrap_or(false)
    }
}

impl ::protobuf::Message for MessageMetadata {
    fn is_initialized(&self) -> bool {
        if self.producer_name.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        if self.publish_time.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encryption_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.publish_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.replicated_from)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partition_key)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.replicate_to)?;
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.compression, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uncompressed_size = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_messages_in_batch = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryption_keys)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryption_algo)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryption_param)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partition_key_b64_encoded = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publish_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.replicated_from.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.partition_key.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.replicate_to {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.compression {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(v) = self.uncompressed_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_messages_in_batch {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_time {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.encryption_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.encryption_algo.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.encryption_param.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.partition_key_b64_encoded {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.publish_time {
            os.write_uint64(3, v)?;
        }
        for v in &self.properties {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.replicated_from.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.partition_key.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.replicate_to {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.compression {
            os.write_enum(8, v.value())?;
        }
        if let Some(v) = self.uncompressed_size {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.num_messages_in_batch {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_uint64(12, v)?;
        }
        for v in &self.encryption_keys {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.encryption_algo.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.encryption_param.as_ref() {
            os.write_bytes(15, &v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(16, &v)?;
        }
        if let Some(v) = self.partition_key_b64_encoded {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageMetadata {
        MessageMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer_name",
                    |m: &MessageMetadata| { &m.producer_name },
                    |m: &mut MessageMetadata| { &mut m.producer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence_id",
                    |m: &MessageMetadata| { &m.sequence_id },
                    |m: &mut MessageMetadata| { &mut m.sequence_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "publish_time",
                    |m: &MessageMetadata| { &m.publish_time },
                    |m: &mut MessageMetadata| { &mut m.publish_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "properties",
                    |m: &MessageMetadata| { &m.properties },
                    |m: &mut MessageMetadata| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "replicated_from",
                    |m: &MessageMetadata| { &m.replicated_from },
                    |m: &mut MessageMetadata| { &mut m.replicated_from },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "partition_key",
                    |m: &MessageMetadata| { &m.partition_key },
                    |m: &mut MessageMetadata| { &mut m.partition_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "replicate_to",
                    |m: &MessageMetadata| { &m.replicate_to },
                    |m: &mut MessageMetadata| { &mut m.replicate_to },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompressionType>>(
                    "compression",
                    |m: &MessageMetadata| { &m.compression },
                    |m: &mut MessageMetadata| { &mut m.compression },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "uncompressed_size",
                    |m: &MessageMetadata| { &m.uncompressed_size },
                    |m: &mut MessageMetadata| { &mut m.uncompressed_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_messages_in_batch",
                    |m: &MessageMetadata| { &m.num_messages_in_batch },
                    |m: &mut MessageMetadata| { &mut m.num_messages_in_batch },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "event_time",
                    |m: &MessageMetadata| { &m.event_time },
                    |m: &mut MessageMetadata| { &mut m.event_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionKeys>>(
                    "encryption_keys",
                    |m: &MessageMetadata| { &m.encryption_keys },
                    |m: &mut MessageMetadata| { &mut m.encryption_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "encryption_algo",
                    |m: &MessageMetadata| { &m.encryption_algo },
                    |m: &mut MessageMetadata| { &mut m.encryption_algo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encryption_param",
                    |m: &MessageMetadata| { &m.encryption_param },
                    |m: &mut MessageMetadata| { &mut m.encryption_param },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "schema_version",
                    |m: &MessageMetadata| { &m.schema_version },
                    |m: &mut MessageMetadata| { &mut m.schema_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "partition_key_b64_encoded",
                    |m: &MessageMetadata| { &m.partition_key_b64_encoded },
                    |m: &mut MessageMetadata| { &mut m.partition_key_b64_encoded },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageMetadata>(
                    "MessageMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageMetadata {
        static mut instance: ::protobuf::lazy::Lazy<MessageMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageMetadata,
        };
        unsafe {
            instance.get(MessageMetadata::new)
        }
    }
}

impl ::protobuf::Clear for MessageMetadata {
    fn clear(&mut self) {
        self.clear_producer_name();
        self.clear_sequence_id();
        self.clear_publish_time();
        self.clear_properties();
        self.clear_replicated_from();
        self.clear_partition_key();
        self.clear_replicate_to();
        self.clear_compression();
        self.clear_uncompressed_size();
        self.clear_num_messages_in_batch();
        self.clear_event_time();
        self.clear_encryption_keys();
        self.clear_encryption_algo();
        self.clear_encryption_param();
        self.clear_schema_version();
        self.clear_partition_key_b64_encoded();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleMessageMetadata {
    // message fields
    properties: ::protobuf::RepeatedField<KeyValue>,
    partition_key: ::protobuf::SingularField<::std::string::String>,
    payload_size: ::std::option::Option<i32>,
    compacted_out: ::std::option::Option<bool>,
    event_time: ::std::option::Option<u64>,
    partition_key_b64_encoded: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SingleMessageMetadata {
    pub fn new() -> SingleMessageMetadata {
        ::std::default::Default::default()
    }

    // repeated .pulsar.proto.KeyValue properties = 1;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[KeyValue] {
        &self.properties
    }

    // optional string partition_key = 2;

    pub fn clear_partition_key(&mut self) {
        self.partition_key.clear();
    }

    pub fn has_partition_key(&self) -> bool {
        self.partition_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key(&mut self, v: ::std::string::String) {
        self.partition_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partition_key(&mut self) -> &mut ::std::string::String {
        if self.partition_key.is_none() {
            self.partition_key.set_default();
        }
        self.partition_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_partition_key(&mut self) -> ::std::string::String {
        self.partition_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_partition_key(&self) -> &str {
        match self.partition_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required int32 payload_size = 3;

    pub fn clear_payload_size(&mut self) {
        self.payload_size = ::std::option::Option::None;
    }

    pub fn has_payload_size(&self) -> bool {
        self.payload_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload_size(&mut self, v: i32) {
        self.payload_size = ::std::option::Option::Some(v);
    }

    pub fn get_payload_size(&self) -> i32 {
        self.payload_size.unwrap_or(0)
    }

    // optional bool compacted_out = 4;

    pub fn clear_compacted_out(&mut self) {
        self.compacted_out = ::std::option::Option::None;
    }

    pub fn has_compacted_out(&self) -> bool {
        self.compacted_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compacted_out(&mut self, v: bool) {
        self.compacted_out = ::std::option::Option::Some(v);
    }

    pub fn get_compacted_out(&self) -> bool {
        self.compacted_out.unwrap_or(false)
    }

    // optional uint64 event_time = 5;

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u64) {
        self.event_time = ::std::option::Option::Some(v);
    }

    pub fn get_event_time(&self) -> u64 {
        self.event_time.unwrap_or(0u64)
    }

    // optional bool partition_key_b64_encoded = 6;

    pub fn clear_partition_key_b64_encoded(&mut self) {
        self.partition_key_b64_encoded = ::std::option::Option::None;
    }

    pub fn has_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition_key_b64_encoded(&mut self, v: bool) {
        self.partition_key_b64_encoded = ::std::option::Option::Some(v);
    }

    pub fn get_partition_key_b64_encoded(&self) -> bool {
        self.partition_key_b64_encoded.unwrap_or(false)
    }
}

impl ::protobuf::Message for SingleMessageMetadata {
    fn is_initialized(&self) -> bool {
        if self.payload_size.is_none() {
            return false;
        }
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.partition_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.payload_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compacted_out = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.partition_key_b64_encoded = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.partition_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.payload_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.compacted_out {
            my_size += 2;
        }
        if let Some(v) = self.event_time {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.partition_key_b64_encoded {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.partition_key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.payload_size {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.compacted_out {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.partition_key_b64_encoded {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleMessageMetadata {
        SingleMessageMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "properties",
                    |m: &SingleMessageMetadata| { &m.properties },
                    |m: &mut SingleMessageMetadata| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "partition_key",
                    |m: &SingleMessageMetadata| { &m.partition_key },
                    |m: &mut SingleMessageMetadata| { &mut m.partition_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "payload_size",
                    |m: &SingleMessageMetadata| { &m.payload_size },
                    |m: &mut SingleMessageMetadata| { &mut m.payload_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "compacted_out",
                    |m: &SingleMessageMetadata| { &m.compacted_out },
                    |m: &mut SingleMessageMetadata| { &mut m.compacted_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "event_time",
                    |m: &SingleMessageMetadata| { &m.event_time },
                    |m: &mut SingleMessageMetadata| { &mut m.event_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "partition_key_b64_encoded",
                    |m: &SingleMessageMetadata| { &m.partition_key_b64_encoded },
                    |m: &mut SingleMessageMetadata| { &mut m.partition_key_b64_encoded },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleMessageMetadata>(
                    "SingleMessageMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleMessageMetadata {
        static mut instance: ::protobuf::lazy::Lazy<SingleMessageMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleMessageMetadata,
        };
        unsafe {
            instance.get(SingleMessageMetadata::new)
        }
    }
}

impl ::protobuf::Clear for SingleMessageMetadata {
    fn clear(&mut self) {
        self.clear_properties();
        self.clear_partition_key();
        self.clear_payload_size();
        self.clear_compacted_out();
        self.clear_event_time();
        self.clear_partition_key_b64_encoded();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleMessageMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleMessageMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandConnect {
    // message fields
    client_version: ::protobuf::SingularField<::std::string::String>,
    auth_method: ::std::option::Option<AuthMethod>,
    auth_method_name: ::protobuf::SingularField<::std::string::String>,
    auth_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    protocol_version: ::std::option::Option<i32>,
    proxy_to_broker_url: ::protobuf::SingularField<::std::string::String>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandConnect {
    pub fn new() -> CommandConnect {
        ::std::default::Default::default()
    }

    // required string client_version = 1;

    pub fn clear_client_version(&mut self) {
        self.client_version.clear();
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: ::std::string::String) {
        self.client_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_version(&mut self) -> &mut ::std::string::String {
        if self.client_version.is_none() {
            self.client_version.set_default();
        }
        self.client_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_version(&mut self) -> ::std::string::String {
        self.client_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client_version(&self) -> &str {
        match self.client_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .pulsar.proto.AuthMethod auth_method = 2;

    pub fn clear_auth_method(&mut self) {
        self.auth_method = ::std::option::Option::None;
    }

    pub fn has_auth_method(&self) -> bool {
        self.auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_method(&mut self, v: AuthMethod) {
        self.auth_method = ::std::option::Option::Some(v);
    }

    pub fn get_auth_method(&self) -> AuthMethod {
        self.auth_method.unwrap_or(AuthMethod::AuthMethodNone)
    }

    // optional string auth_method_name = 5;

    pub fn clear_auth_method_name(&mut self) {
        self.auth_method_name.clear();
    }

    pub fn has_auth_method_name(&self) -> bool {
        self.auth_method_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_method_name(&mut self, v: ::std::string::String) {
        self.auth_method_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_method_name(&mut self) -> &mut ::std::string::String {
        if self.auth_method_name.is_none() {
            self.auth_method_name.set_default();
        }
        self.auth_method_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_method_name(&mut self) -> ::std::string::String {
        self.auth_method_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_auth_method_name(&self) -> &str {
        match self.auth_method_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes auth_data = 3;

    pub fn clear_auth_data(&mut self) {
        self.auth_data.clear();
    }

    pub fn has_auth_data(&self) -> bool {
        self.auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.auth_data.is_none() {
            self.auth_data.set_default();
        }
        self.auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_data(&mut self) -> ::std::vec::Vec<u8> {
        self.auth_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_auth_data(&self) -> &[u8] {
        match self.auth_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 protocol_version = 4;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }

    // optional string proxy_to_broker_url = 6;

    pub fn clear_proxy_to_broker_url(&mut self) {
        self.proxy_to_broker_url.clear();
    }

    pub fn has_proxy_to_broker_url(&self) -> bool {
        self.proxy_to_broker_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_to_broker_url(&mut self, v: ::std::string::String) {
        self.proxy_to_broker_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proxy_to_broker_url(&mut self) -> &mut ::std::string::String {
        if self.proxy_to_broker_url.is_none() {
            self.proxy_to_broker_url.set_default();
        }
        self.proxy_to_broker_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_proxy_to_broker_url(&mut self) -> ::std::string::String {
        self.proxy_to_broker_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_proxy_to_broker_url(&self) -> &str {
        match self.proxy_to_broker_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_principal = 7;

    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_data = 8;

    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_method = 9;

    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandConnect {
    fn is_initialized(&self) -> bool {
        if self.client_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_version)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.auth_method, 2, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.auth_method_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.auth_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.proxy_to_broker_url)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.auth_method {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.auth_method_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.proxy_to_broker_url.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.auth_method {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.auth_method_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.auth_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.proxy_to_broker_url.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConnect {
        CommandConnect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client_version",
                    |m: &CommandConnect| { &m.client_version },
                    |m: &mut CommandConnect| { &mut m.client_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthMethod>>(
                    "auth_method",
                    |m: &CommandConnect| { &m.auth_method },
                    |m: &mut CommandConnect| { &mut m.auth_method },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_method_name",
                    |m: &CommandConnect| { &m.auth_method_name },
                    |m: &mut CommandConnect| { &mut m.auth_method_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "auth_data",
                    |m: &CommandConnect| { &m.auth_data },
                    |m: &mut CommandConnect| { &mut m.auth_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "protocol_version",
                    |m: &CommandConnect| { &m.protocol_version },
                    |m: &mut CommandConnect| { &mut m.protocol_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "proxy_to_broker_url",
                    |m: &CommandConnect| { &m.proxy_to_broker_url },
                    |m: &mut CommandConnect| { &mut m.proxy_to_broker_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_principal",
                    |m: &CommandConnect| { &m.original_principal },
                    |m: &mut CommandConnect| { &mut m.original_principal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_data",
                    |m: &CommandConnect| { &m.original_auth_data },
                    |m: &mut CommandConnect| { &mut m.original_auth_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_method",
                    |m: &CommandConnect| { &m.original_auth_method },
                    |m: &mut CommandConnect| { &mut m.original_auth_method },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandConnect>(
                    "CommandConnect",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandConnect {
        static mut instance: ::protobuf::lazy::Lazy<CommandConnect> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandConnect,
        };
        unsafe {
            instance.get(CommandConnect::new)
        }
    }
}

impl ::protobuf::Clear for CommandConnect {
    fn clear(&mut self) {
        self.clear_client_version();
        self.clear_auth_method();
        self.clear_auth_method_name();
        self.clear_auth_data();
        self.clear_protocol_version();
        self.clear_proxy_to_broker_url();
        self.clear_original_principal();
        self.clear_original_auth_data();
        self.clear_original_auth_method();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConnect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandConnected {
    // message fields
    server_version: ::protobuf::SingularField<::std::string::String>,
    protocol_version: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandConnected {
    pub fn new() -> CommandConnected {
        ::std::default::Default::default()
    }

    // required string server_version = 1;

    pub fn clear_server_version(&mut self) {
        self.server_version.clear();
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: ::std::string::String) {
        self.server_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_version(&mut self) -> &mut ::std::string::String {
        if self.server_version.is_none() {
            self.server_version.set_default();
        }
        self.server_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_version(&mut self) -> ::std::string::String {
        self.server_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_server_version(&self) -> &str {
        match self.server_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 protocol_version = 2;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: i32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version(&self) -> i32 {
        self.protocol_version.unwrap_or(0i32)
    }
}

impl ::protobuf::Message for CommandConnected {
    fn is_initialized(&self) -> bool {
        if self.server_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server_version.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConnected {
        CommandConnected::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server_version",
                    |m: &CommandConnected| { &m.server_version },
                    |m: &mut CommandConnected| { &mut m.server_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "protocol_version",
                    |m: &CommandConnected| { &m.protocol_version },
                    |m: &mut CommandConnected| { &mut m.protocol_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandConnected>(
                    "CommandConnected",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandConnected {
        static mut instance: ::protobuf::lazy::Lazy<CommandConnected> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandConnected,
        };
        unsafe {
            instance.get(CommandConnected::new)
        }
    }
}

impl ::protobuf::Clear for CommandConnected {
    fn clear(&mut self) {
        self.clear_server_version();
        self.clear_protocol_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandConnected {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConnected {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSubscribe {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    subscription: ::protobuf::SingularField<::std::string::String>,
    subType: ::std::option::Option<CommandSubscribe_SubType>,
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    consumer_name: ::protobuf::SingularField<::std::string::String>,
    priority_level: ::std::option::Option<i32>,
    durable: ::std::option::Option<bool>,
    start_message_id: ::protobuf::SingularPtrField<MessageIdData>,
    metadata: ::protobuf::RepeatedField<KeyValue>,
    read_compacted: ::std::option::Option<bool>,
    schema: ::protobuf::SingularPtrField<Schema>,
    initialPosition: ::std::option::Option<CommandSubscribe_InitialPosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSubscribe {
    pub fn new() -> CommandSubscribe {
        ::std::default::Default::default()
    }

    // required string topic = 1;

    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string subscription = 2;

    pub fn clear_subscription(&mut self) {
        self.subscription.clear();
    }

    pub fn has_subscription(&self) -> bool {
        self.subscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscription(&mut self, v: ::std::string::String) {
        self.subscription = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscription(&mut self) -> &mut ::std::string::String {
        if self.subscription.is_none() {
            self.subscription.set_default();
        }
        self.subscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscription(&mut self) -> ::std::string::String {
        self.subscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_subscription(&self) -> &str {
        match self.subscription.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .pulsar.proto.CommandSubscribe.SubType subType = 3;

    pub fn clear_subType(&mut self) {
        self.subType = ::std::option::Option::None;
    }

    pub fn has_subType(&self) -> bool {
        self.subType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subType(&mut self, v: CommandSubscribe_SubType) {
        self.subType = ::std::option::Option::Some(v);
    }

    pub fn get_subType(&self) -> CommandSubscribe_SubType {
        self.subType.unwrap_or(CommandSubscribe_SubType::Exclusive)
    }

    // required uint64 consumer_id = 4;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint64 request_id = 5;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional string consumer_name = 6;

    pub fn clear_consumer_name(&mut self) {
        self.consumer_name.clear();
    }

    pub fn has_consumer_name(&self) -> bool {
        self.consumer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_name(&mut self, v: ::std::string::String) {
        self.consumer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer_name(&mut self) -> &mut ::std::string::String {
        if self.consumer_name.is_none() {
            self.consumer_name.set_default();
        }
        self.consumer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumer_name(&mut self) -> ::std::string::String {
        self.consumer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_consumer_name(&self) -> &str {
        match self.consumer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 priority_level = 7;

    pub fn clear_priority_level(&mut self) {
        self.priority_level = ::std::option::Option::None;
    }

    pub fn has_priority_level(&self) -> bool {
        self.priority_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_level(&mut self, v: i32) {
        self.priority_level = ::std::option::Option::Some(v);
    }

    pub fn get_priority_level(&self) -> i32 {
        self.priority_level.unwrap_or(0)
    }

    // optional bool durable = 8;

    pub fn clear_durable(&mut self) {
        self.durable = ::std::option::Option::None;
    }

    pub fn has_durable(&self) -> bool {
        self.durable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_durable(&mut self, v: bool) {
        self.durable = ::std::option::Option::Some(v);
    }

    pub fn get_durable(&self) -> bool {
        self.durable.unwrap_or(true)
    }

    // optional .pulsar.proto.MessageIdData start_message_id = 9;

    pub fn clear_start_message_id(&mut self) {
        self.start_message_id.clear();
    }

    pub fn has_start_message_id(&self) -> bool {
        self.start_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_message_id(&mut self, v: MessageIdData) {
        self.start_message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_message_id(&mut self) -> &mut MessageIdData {
        if self.start_message_id.is_none() {
            self.start_message_id.set_default();
        }
        self.start_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_message_id(&mut self) -> MessageIdData {
        self.start_message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    pub fn get_start_message_id(&self) -> &MessageIdData {
        self.start_message_id.as_ref().unwrap_or_else(|| MessageIdData::default_instance())
    }

    // repeated .pulsar.proto.KeyValue metadata = 10;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }

    // optional bool read_compacted = 11;

    pub fn clear_read_compacted(&mut self) {
        self.read_compacted = ::std::option::Option::None;
    }

    pub fn has_read_compacted(&self) -> bool {
        self.read_compacted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_compacted(&mut self, v: bool) {
        self.read_compacted = ::std::option::Option::Some(v);
    }

    pub fn get_read_compacted(&self) -> bool {
        self.read_compacted.unwrap_or(false)
    }

    // optional .pulsar.proto.Schema schema = 12;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // optional .pulsar.proto.CommandSubscribe.InitialPosition initialPosition = 13;

    pub fn clear_initialPosition(&mut self) {
        self.initialPosition = ::std::option::Option::None;
    }

    pub fn has_initialPosition(&self) -> bool {
        self.initialPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialPosition(&mut self, v: CommandSubscribe_InitialPosition) {
        self.initialPosition = ::std::option::Option::Some(v);
    }

    pub fn get_initialPosition(&self) -> CommandSubscribe_InitialPosition {
        self.initialPosition.unwrap_or(CommandSubscribe_InitialPosition::Latest)
    }
}

impl ::protobuf::Message for CommandSubscribe {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.subscription.is_none() {
            return false;
        }
        if self.subType.is_none() {
            return false;
        }
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.start_message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subscription)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.subType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumer_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority_level = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.durable = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_message_id)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.read_compacted = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                13 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.initialPosition, 13, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.subscription.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.subType {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.consumer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.priority_level {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.durable {
            my_size += 2;
        }
        if let Some(ref v) = self.start_message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.read_compacted {
            my_size += 2;
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.initialPosition {
            my_size += ::protobuf::rt::enum_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.subscription.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.subType {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.consumer_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.consumer_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.priority_level {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.durable {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.start_message_id.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.read_compacted {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.initialPosition {
            os.write_enum(13, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSubscribe {
        CommandSubscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &CommandSubscribe| { &m.topic },
                    |m: &mut CommandSubscribe| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subscription",
                    |m: &CommandSubscribe| { &m.subscription },
                    |m: &mut CommandSubscribe| { &mut m.subscription },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandSubscribe_SubType>>(
                    "subType",
                    |m: &CommandSubscribe| { &m.subType },
                    |m: &mut CommandSubscribe| { &mut m.subType },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandSubscribe| { &m.consumer_id },
                    |m: &mut CommandSubscribe| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandSubscribe| { &m.request_id },
                    |m: &mut CommandSubscribe| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "consumer_name",
                    |m: &CommandSubscribe| { &m.consumer_name },
                    |m: &mut CommandSubscribe| { &mut m.consumer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "priority_level",
                    |m: &CommandSubscribe| { &m.priority_level },
                    |m: &mut CommandSubscribe| { &mut m.priority_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "durable",
                    |m: &CommandSubscribe| { &m.durable },
                    |m: &mut CommandSubscribe| { &mut m.durable },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "start_message_id",
                    |m: &CommandSubscribe| { &m.start_message_id },
                    |m: &mut CommandSubscribe| { &mut m.start_message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "metadata",
                    |m: &CommandSubscribe| { &m.metadata },
                    |m: &mut CommandSubscribe| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "read_compacted",
                    |m: &CommandSubscribe| { &m.read_compacted },
                    |m: &mut CommandSubscribe| { &mut m.read_compacted },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &CommandSubscribe| { &m.schema },
                    |m: &mut CommandSubscribe| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandSubscribe_InitialPosition>>(
                    "initialPosition",
                    |m: &CommandSubscribe| { &m.initialPosition },
                    |m: &mut CommandSubscribe| { &mut m.initialPosition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSubscribe>(
                    "CommandSubscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSubscribe {
        static mut instance: ::protobuf::lazy::Lazy<CommandSubscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSubscribe,
        };
        unsafe {
            instance.get(CommandSubscribe::new)
        }
    }
}

impl ::protobuf::Clear for CommandSubscribe {
    fn clear(&mut self) {
        self.clear_topic();
        self.clear_subscription();
        self.clear_subType();
        self.clear_consumer_id();
        self.clear_request_id();
        self.clear_consumer_name();
        self.clear_priority_level();
        self.clear_durable();
        self.clear_start_message_id();
        self.clear_metadata();
        self.clear_read_compacted();
        self.clear_schema();
        self.clear_initialPosition();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandSubscribe_SubType {
    Exclusive = 0,
    Shared = 1,
    Failover = 2,
}

impl ::protobuf::ProtobufEnum for CommandSubscribe_SubType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandSubscribe_SubType> {
        match value {
            0 => ::std::option::Option::Some(CommandSubscribe_SubType::Exclusive),
            1 => ::std::option::Option::Some(CommandSubscribe_SubType::Shared),
            2 => ::std::option::Option::Some(CommandSubscribe_SubType::Failover),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandSubscribe_SubType] = &[
            CommandSubscribe_SubType::Exclusive,
            CommandSubscribe_SubType::Shared,
            CommandSubscribe_SubType::Failover,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandSubscribe_SubType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandSubscribe_SubType {
}

impl ::std::default::Default for CommandSubscribe_SubType {
    fn default() -> Self {
        CommandSubscribe_SubType::Exclusive
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe_SubType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandSubscribe_InitialPosition {
    Latest = 0,
    Earliest = 1,
}

impl ::protobuf::ProtobufEnum for CommandSubscribe_InitialPosition {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandSubscribe_InitialPosition> {
        match value {
            0 => ::std::option::Option::Some(CommandSubscribe_InitialPosition::Latest),
            1 => ::std::option::Option::Some(CommandSubscribe_InitialPosition::Earliest),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandSubscribe_InitialPosition] = &[
            CommandSubscribe_InitialPosition::Latest,
            CommandSubscribe_InitialPosition::Earliest,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandSubscribe_InitialPosition", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandSubscribe_InitialPosition {
}

impl ::std::default::Default for CommandSubscribe_InitialPosition {
    fn default() -> Self {
        CommandSubscribe_InitialPosition::Latest
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSubscribe_InitialPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPartitionedTopicMetadata {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    request_id: ::std::option::Option<u64>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandPartitionedTopicMetadata {
    pub fn new() -> CommandPartitionedTopicMetadata {
        ::std::default::Default::default()
    }

    // required string topic = 1;

    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional string original_principal = 3;

    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_data = 4;

    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_method = 5;

    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandPartitionedTopicMetadata {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPartitionedTopicMetadata {
        CommandPartitionedTopicMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &CommandPartitionedTopicMetadata| { &m.topic },
                    |m: &mut CommandPartitionedTopicMetadata| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandPartitionedTopicMetadata| { &m.request_id },
                    |m: &mut CommandPartitionedTopicMetadata| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_principal",
                    |m: &CommandPartitionedTopicMetadata| { &m.original_principal },
                    |m: &mut CommandPartitionedTopicMetadata| { &mut m.original_principal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_data",
                    |m: &CommandPartitionedTopicMetadata| { &m.original_auth_data },
                    |m: &mut CommandPartitionedTopicMetadata| { &mut m.original_auth_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_method",
                    |m: &CommandPartitionedTopicMetadata| { &m.original_auth_method },
                    |m: &mut CommandPartitionedTopicMetadata| { &mut m.original_auth_method },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandPartitionedTopicMetadata>(
                    "CommandPartitionedTopicMetadata",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandPartitionedTopicMetadata {
        static mut instance: ::protobuf::lazy::Lazy<CommandPartitionedTopicMetadata> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandPartitionedTopicMetadata,
        };
        unsafe {
            instance.get(CommandPartitionedTopicMetadata::new)
        }
    }
}

impl ::protobuf::Clear for CommandPartitionedTopicMetadata {
    fn clear(&mut self) {
        self.clear_topic();
        self.clear_request_id();
        self.clear_original_principal();
        self.clear_original_auth_data();
        self.clear_original_auth_method();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPartitionedTopicMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPartitionedTopicMetadataResponse {
    // message fields
    partitions: ::std::option::Option<u32>,
    request_id: ::std::option::Option<u64>,
    response: ::std::option::Option<CommandPartitionedTopicMetadataResponse_LookupType>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandPartitionedTopicMetadataResponse {
    pub fn new() -> CommandPartitionedTopicMetadataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 partitions = 1;

    pub fn clear_partitions(&mut self) {
        self.partitions = ::std::option::Option::None;
    }

    pub fn has_partitions(&self) -> bool {
        self.partitions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: u32) {
        self.partitions = ::std::option::Option::Some(v);
    }

    pub fn get_partitions(&self) -> u32 {
        self.partitions.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse.LookupType response = 3;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommandPartitionedTopicMetadataResponse_LookupType) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CommandPartitionedTopicMetadataResponse_LookupType {
        self.response.unwrap_or(CommandPartitionedTopicMetadataResponse_LookupType::Success)
    }

    // optional .pulsar.proto.ServerError error = 4;

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }

    // optional string message = 5;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandPartitionedTopicMetadataResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partitions = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.partitions {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.partitions {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.error {
            os.write_enum(4, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPartitionedTopicMetadataResponse {
        CommandPartitionedTopicMetadataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partitions",
                    |m: &CommandPartitionedTopicMetadataResponse| { &m.partitions },
                    |m: &mut CommandPartitionedTopicMetadataResponse| { &mut m.partitions },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandPartitionedTopicMetadataResponse| { &m.request_id },
                    |m: &mut CommandPartitionedTopicMetadataResponse| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandPartitionedTopicMetadataResponse_LookupType>>(
                    "response",
                    |m: &CommandPartitionedTopicMetadataResponse| { &m.response },
                    |m: &mut CommandPartitionedTopicMetadataResponse| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error",
                    |m: &CommandPartitionedTopicMetadataResponse| { &m.error },
                    |m: &mut CommandPartitionedTopicMetadataResponse| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CommandPartitionedTopicMetadataResponse| { &m.message },
                    |m: &mut CommandPartitionedTopicMetadataResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandPartitionedTopicMetadataResponse>(
                    "CommandPartitionedTopicMetadataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandPartitionedTopicMetadataResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandPartitionedTopicMetadataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandPartitionedTopicMetadataResponse,
        };
        unsafe {
            instance.get(CommandPartitionedTopicMetadataResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandPartitionedTopicMetadataResponse {
    fn clear(&mut self) {
        self.clear_partitions();
        self.clear_request_id();
        self.clear_response();
        self.clear_error();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPartitionedTopicMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandPartitionedTopicMetadataResponse_LookupType {
    Success = 0,
    Failed = 1,
}

impl ::protobuf::ProtobufEnum for CommandPartitionedTopicMetadataResponse_LookupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandPartitionedTopicMetadataResponse_LookupType> {
        match value {
            0 => ::std::option::Option::Some(CommandPartitionedTopicMetadataResponse_LookupType::Success),
            1 => ::std::option::Option::Some(CommandPartitionedTopicMetadataResponse_LookupType::Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandPartitionedTopicMetadataResponse_LookupType] = &[
            CommandPartitionedTopicMetadataResponse_LookupType::Success,
            CommandPartitionedTopicMetadataResponse_LookupType::Failed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandPartitionedTopicMetadataResponse_LookupType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandPartitionedTopicMetadataResponse_LookupType {
}

impl ::std::default::Default for CommandPartitionedTopicMetadataResponse_LookupType {
    fn default() -> Self {
        CommandPartitionedTopicMetadataResponse_LookupType::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPartitionedTopicMetadataResponse_LookupType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandLookupTopic {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    request_id: ::std::option::Option<u64>,
    authoritative: ::std::option::Option<bool>,
    original_principal: ::protobuf::SingularField<::std::string::String>,
    original_auth_data: ::protobuf::SingularField<::std::string::String>,
    original_auth_method: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandLookupTopic {
    pub fn new() -> CommandLookupTopic {
        ::std::default::Default::default()
    }

    // required string topic = 1;

    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional bool authoritative = 3;

    pub fn clear_authoritative(&mut self) {
        self.authoritative = ::std::option::Option::None;
    }

    pub fn has_authoritative(&self) -> bool {
        self.authoritative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = ::std::option::Option::Some(v);
    }

    pub fn get_authoritative(&self) -> bool {
        self.authoritative.unwrap_or(false)
    }

    // optional string original_principal = 4;

    pub fn clear_original_principal(&mut self) {
        self.original_principal.clear();
    }

    pub fn has_original_principal(&self) -> bool {
        self.original_principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_principal(&mut self, v: ::std::string::String) {
        self.original_principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_principal(&mut self) -> &mut ::std::string::String {
        if self.original_principal.is_none() {
            self.original_principal.set_default();
        }
        self.original_principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_principal(&mut self) -> ::std::string::String {
        self.original_principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_principal(&self) -> &str {
        match self.original_principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_data = 5;

    pub fn clear_original_auth_data(&mut self) {
        self.original_auth_data.clear();
    }

    pub fn has_original_auth_data(&self) -> bool {
        self.original_auth_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_data(&mut self, v: ::std::string::String) {
        self.original_auth_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_data(&mut self) -> &mut ::std::string::String {
        if self.original_auth_data.is_none() {
            self.original_auth_data.set_default();
        }
        self.original_auth_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_data(&mut self) -> ::std::string::String {
        self.original_auth_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_data(&self) -> &str {
        match self.original_auth_data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string original_auth_method = 6;

    pub fn clear_original_auth_method(&mut self) {
        self.original_auth_method.clear();
    }

    pub fn has_original_auth_method(&self) -> bool {
        self.original_auth_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_auth_method(&mut self, v: ::std::string::String) {
        self.original_auth_method = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_auth_method(&mut self) -> &mut ::std::string::String {
        if self.original_auth_method.is_none() {
            self.original_auth_method.set_default();
        }
        self.original_auth_method.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_auth_method(&mut self) -> ::std::string::String {
        self.original_auth_method.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_original_auth_method(&self) -> &str {
        match self.original_auth_method.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandLookupTopic {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_principal)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.original_auth_method)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authoritative {
            my_size += 2;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.authoritative {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.original_principal.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.original_auth_data.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.original_auth_method.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandLookupTopic {
        CommandLookupTopic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &CommandLookupTopic| { &m.topic },
                    |m: &mut CommandLookupTopic| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandLookupTopic| { &m.request_id },
                    |m: &mut CommandLookupTopic| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "authoritative",
                    |m: &CommandLookupTopic| { &m.authoritative },
                    |m: &mut CommandLookupTopic| { &mut m.authoritative },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_principal",
                    |m: &CommandLookupTopic| { &m.original_principal },
                    |m: &mut CommandLookupTopic| { &mut m.original_principal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_data",
                    |m: &CommandLookupTopic| { &m.original_auth_data },
                    |m: &mut CommandLookupTopic| { &mut m.original_auth_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "original_auth_method",
                    |m: &CommandLookupTopic| { &m.original_auth_method },
                    |m: &mut CommandLookupTopic| { &mut m.original_auth_method },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandLookupTopic>(
                    "CommandLookupTopic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandLookupTopic {
        static mut instance: ::protobuf::lazy::Lazy<CommandLookupTopic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandLookupTopic,
        };
        unsafe {
            instance.get(CommandLookupTopic::new)
        }
    }
}

impl ::protobuf::Clear for CommandLookupTopic {
    fn clear(&mut self) {
        self.clear_topic();
        self.clear_request_id();
        self.clear_authoritative();
        self.clear_original_principal();
        self.clear_original_auth_data();
        self.clear_original_auth_method();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandLookupTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandLookupTopicResponse {
    // message fields
    brokerServiceUrl: ::protobuf::SingularField<::std::string::String>,
    brokerServiceUrlTls: ::protobuf::SingularField<::std::string::String>,
    response: ::std::option::Option<CommandLookupTopicResponse_LookupType>,
    request_id: ::std::option::Option<u64>,
    authoritative: ::std::option::Option<bool>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    proxy_through_service_url: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandLookupTopicResponse {
    pub fn new() -> CommandLookupTopicResponse {
        ::std::default::Default::default()
    }

    // optional string brokerServiceUrl = 1;

    pub fn clear_brokerServiceUrl(&mut self) {
        self.brokerServiceUrl.clear();
    }

    pub fn has_brokerServiceUrl(&self) -> bool {
        self.brokerServiceUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerServiceUrl(&mut self, v: ::std::string::String) {
        self.brokerServiceUrl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerServiceUrl(&mut self) -> &mut ::std::string::String {
        if self.brokerServiceUrl.is_none() {
            self.brokerServiceUrl.set_default();
        }
        self.brokerServiceUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerServiceUrl(&mut self) -> ::std::string::String {
        self.brokerServiceUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_brokerServiceUrl(&self) -> &str {
        match self.brokerServiceUrl.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string brokerServiceUrlTls = 2;

    pub fn clear_brokerServiceUrlTls(&mut self) {
        self.brokerServiceUrlTls.clear();
    }

    pub fn has_brokerServiceUrlTls(&self) -> bool {
        self.brokerServiceUrlTls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerServiceUrlTls(&mut self, v: ::std::string::String) {
        self.brokerServiceUrlTls = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerServiceUrlTls(&mut self) -> &mut ::std::string::String {
        if self.brokerServiceUrlTls.is_none() {
            self.brokerServiceUrlTls.set_default();
        }
        self.brokerServiceUrlTls.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerServiceUrlTls(&mut self) -> ::std::string::String {
        self.brokerServiceUrlTls.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_brokerServiceUrlTls(&self) -> &str {
        match self.brokerServiceUrlTls.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .pulsar.proto.CommandLookupTopicResponse.LookupType response = 3;

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommandLookupTopicResponse_LookupType) {
        self.response = ::std::option::Option::Some(v);
    }

    pub fn get_response(&self) -> CommandLookupTopicResponse_LookupType {
        self.response.unwrap_or(CommandLookupTopicResponse_LookupType::Redirect)
    }

    // required uint64 request_id = 4;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional bool authoritative = 5;

    pub fn clear_authoritative(&mut self) {
        self.authoritative = ::std::option::Option::None;
    }

    pub fn has_authoritative(&self) -> bool {
        self.authoritative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authoritative(&mut self, v: bool) {
        self.authoritative = ::std::option::Option::Some(v);
    }

    pub fn get_authoritative(&self) -> bool {
        self.authoritative.unwrap_or(false)
    }

    // optional .pulsar.proto.ServerError error = 6;

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }

    // optional string message = 7;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool proxy_through_service_url = 8;

    pub fn clear_proxy_through_service_url(&mut self) {
        self.proxy_through_service_url = ::std::option::Option::None;
    }

    pub fn has_proxy_through_service_url(&self) -> bool {
        self.proxy_through_service_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy_through_service_url(&mut self, v: bool) {
        self.proxy_through_service_url = ::std::option::Option::Some(v);
    }

    pub fn get_proxy_through_service_url(&self) -> bool {
        self.proxy_through_service_url.unwrap_or(false)
    }
}

impl ::protobuf::Message for CommandLookupTopicResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.brokerServiceUrl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.brokerServiceUrlTls)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authoritative = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxy_through_service_url = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.brokerServiceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.brokerServiceUrlTls.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.authoritative {
            my_size += 2;
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.proxy_through_service_url {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.brokerServiceUrl.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.brokerServiceUrlTls.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.authoritative {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(6, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.proxy_through_service_url {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandLookupTopicResponse {
        CommandLookupTopicResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "brokerServiceUrl",
                    |m: &CommandLookupTopicResponse| { &m.brokerServiceUrl },
                    |m: &mut CommandLookupTopicResponse| { &mut m.brokerServiceUrl },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "brokerServiceUrlTls",
                    |m: &CommandLookupTopicResponse| { &m.brokerServiceUrlTls },
                    |m: &mut CommandLookupTopicResponse| { &mut m.brokerServiceUrlTls },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandLookupTopicResponse_LookupType>>(
                    "response",
                    |m: &CommandLookupTopicResponse| { &m.response },
                    |m: &mut CommandLookupTopicResponse| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandLookupTopicResponse| { &m.request_id },
                    |m: &mut CommandLookupTopicResponse| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "authoritative",
                    |m: &CommandLookupTopicResponse| { &m.authoritative },
                    |m: &mut CommandLookupTopicResponse| { &mut m.authoritative },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error",
                    |m: &CommandLookupTopicResponse| { &m.error },
                    |m: &mut CommandLookupTopicResponse| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CommandLookupTopicResponse| { &m.message },
                    |m: &mut CommandLookupTopicResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "proxy_through_service_url",
                    |m: &CommandLookupTopicResponse| { &m.proxy_through_service_url },
                    |m: &mut CommandLookupTopicResponse| { &mut m.proxy_through_service_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandLookupTopicResponse>(
                    "CommandLookupTopicResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandLookupTopicResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandLookupTopicResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandLookupTopicResponse,
        };
        unsafe {
            instance.get(CommandLookupTopicResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandLookupTopicResponse {
    fn clear(&mut self) {
        self.clear_brokerServiceUrl();
        self.clear_brokerServiceUrlTls();
        self.clear_response();
        self.clear_request_id();
        self.clear_authoritative();
        self.clear_error();
        self.clear_message();
        self.clear_proxy_through_service_url();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandLookupTopicResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopicResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandLookupTopicResponse_LookupType {
    Redirect = 0,
    Connect = 1,
    Failed = 2,
}

impl ::protobuf::ProtobufEnum for CommandLookupTopicResponse_LookupType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandLookupTopicResponse_LookupType> {
        match value {
            0 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Redirect),
            1 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Connect),
            2 => ::std::option::Option::Some(CommandLookupTopicResponse_LookupType::Failed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandLookupTopicResponse_LookupType] = &[
            CommandLookupTopicResponse_LookupType::Redirect,
            CommandLookupTopicResponse_LookupType::Connect,
            CommandLookupTopicResponse_LookupType::Failed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandLookupTopicResponse_LookupType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandLookupTopicResponse_LookupType {
}

impl ::std::default::Default for CommandLookupTopicResponse_LookupType {
    fn default() -> Self {
        CommandLookupTopicResponse_LookupType::Redirect
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandLookupTopicResponse_LookupType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandProducer {
    // message fields
    topic: ::protobuf::SingularField<::std::string::String>,
    producer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    producer_name: ::protobuf::SingularField<::std::string::String>,
    encrypted: ::std::option::Option<bool>,
    metadata: ::protobuf::RepeatedField<KeyValue>,
    schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandProducer {
    pub fn new() -> CommandProducer {
        ::std::default::Default::default()
    }

    // required string topic = 1;

    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint64 producer_id = 2;

    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }

    // required uint64 request_id = 3;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional string producer_name = 4;

    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool encrypted = 5;

    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }

    pub fn get_encrypted(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }

    // repeated .pulsar.proto.KeyValue metadata = 6;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.metadata, ::protobuf::RepeatedField::new())
    }

    pub fn get_metadata(&self) -> &[KeyValue] {
        &self.metadata
    }

    // optional .pulsar.proto.Schema schema = 7;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }
}

impl ::protobuf::Message for CommandProducer {
    fn is_initialized(&self) -> bool {
        if self.topic.is_none() {
            return false;
        }
        if self.producer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encrypted = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metadata)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.encrypted {
            my_size += 2;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.producer_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.encrypted {
            os.write_bool(5, v)?;
        }
        for v in &self.metadata {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandProducer {
        CommandProducer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &CommandProducer| { &m.topic },
                    |m: &mut CommandProducer| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "producer_id",
                    |m: &CommandProducer| { &m.producer_id },
                    |m: &mut CommandProducer| { &mut m.producer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandProducer| { &m.request_id },
                    |m: &mut CommandProducer| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer_name",
                    |m: &CommandProducer| { &m.producer_name },
                    |m: &mut CommandProducer| { &mut m.producer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "encrypted",
                    |m: &CommandProducer| { &m.encrypted },
                    |m: &mut CommandProducer| { &mut m.encrypted },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "metadata",
                    |m: &CommandProducer| { &m.metadata },
                    |m: &mut CommandProducer| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &CommandProducer| { &m.schema },
                    |m: &mut CommandProducer| { &mut m.schema },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandProducer>(
                    "CommandProducer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandProducer {
        static mut instance: ::protobuf::lazy::Lazy<CommandProducer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandProducer,
        };
        unsafe {
            instance.get(CommandProducer::new)
        }
    }
}

impl ::protobuf::Clear for CommandProducer {
    fn clear(&mut self) {
        self.clear_topic();
        self.clear_producer_id();
        self.clear_request_id();
        self.clear_producer_name();
        self.clear_encrypted();
        self.clear_metadata();
        self.clear_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandProducer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandProducer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSend {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    num_messages: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSend {
    pub fn new() -> CommandSend {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;

    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }

    // required uint64 sequence_id = 2;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }

    // optional int32 num_messages = 3;

    pub fn clear_num_messages(&mut self) {
        self.num_messages = ::std::option::Option::None;
    }

    pub fn has_num_messages(&self) -> bool {
        self.num_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: i32) {
        self.num_messages = ::std::option::Option::Some(v);
    }

    pub fn get_num_messages(&self) -> i32 {
        self.num_messages.unwrap_or(1i32)
    }
}

impl ::protobuf::Message for CommandSend {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_messages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_messages {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.num_messages {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSend {
        CommandSend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "producer_id",
                    |m: &CommandSend| { &m.producer_id },
                    |m: &mut CommandSend| { &mut m.producer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence_id",
                    |m: &CommandSend| { &m.sequence_id },
                    |m: &mut CommandSend| { &mut m.sequence_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_messages",
                    |m: &CommandSend| { &m.num_messages },
                    |m: &mut CommandSend| { &mut m.num_messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSend>(
                    "CommandSend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSend {
        static mut instance: ::protobuf::lazy::Lazy<CommandSend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSend,
        };
        unsafe {
            instance.get(CommandSend::new)
        }
    }
}

impl ::protobuf::Clear for CommandSend {
    fn clear(&mut self) {
        self.clear_producer_id();
        self.clear_sequence_id();
        self.clear_num_messages();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSend {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSendReceipt {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    message_id: ::protobuf::SingularPtrField<MessageIdData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSendReceipt {
    pub fn new() -> CommandSendReceipt {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;

    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }

    // required uint64 sequence_id = 2;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }

    // optional .pulsar.proto.MessageIdData message_id = 3;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| MessageIdData::default_instance())
    }
}

impl ::protobuf::Message for CommandSendReceipt {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSendReceipt {
        CommandSendReceipt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "producer_id",
                    |m: &CommandSendReceipt| { &m.producer_id },
                    |m: &mut CommandSendReceipt| { &mut m.producer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence_id",
                    |m: &CommandSendReceipt| { &m.sequence_id },
                    |m: &mut CommandSendReceipt| { &mut m.sequence_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "message_id",
                    |m: &CommandSendReceipt| { &m.message_id },
                    |m: &mut CommandSendReceipt| { &mut m.message_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSendReceipt>(
                    "CommandSendReceipt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSendReceipt {
        static mut instance: ::protobuf::lazy::Lazy<CommandSendReceipt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSendReceipt,
        };
        unsafe {
            instance.get(CommandSendReceipt::new)
        }
    }
}

impl ::protobuf::Clear for CommandSendReceipt {
    fn clear(&mut self) {
        self.clear_producer_id();
        self.clear_sequence_id();
        self.clear_message_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSendReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSendReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSendError {
    // message fields
    producer_id: ::std::option::Option<u64>,
    sequence_id: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSendError {
    pub fn new() -> CommandSendError {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;

    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }

    // required uint64 sequence_id = 2;

    pub fn clear_sequence_id(&mut self) {
        self.sequence_id = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        self.sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: u64) {
        self.sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_sequence_id(&self) -> u64 {
        self.sequence_id.unwrap_or(0)
    }

    // required .pulsar.proto.ServerError error = 3;

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }

    // required string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandSendError {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.sequence_id.is_none() {
            return false;
        }
        if self.error.is_none() {
            return false;
        }
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sequence_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sequence_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sequence_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(3, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSendError {
        CommandSendError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "producer_id",
                    |m: &CommandSendError| { &m.producer_id },
                    |m: &mut CommandSendError| { &mut m.producer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sequence_id",
                    |m: &CommandSendError| { &m.sequence_id },
                    |m: &mut CommandSendError| { &mut m.sequence_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error",
                    |m: &CommandSendError| { &m.error },
                    |m: &mut CommandSendError| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CommandSendError| { &m.message },
                    |m: &mut CommandSendError| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSendError>(
                    "CommandSendError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSendError {
        static mut instance: ::protobuf::lazy::Lazy<CommandSendError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSendError,
        };
        unsafe {
            instance.get(CommandSendError::new)
        }
    }
}

impl ::protobuf::Clear for CommandSendError {
    fn clear(&mut self) {
        self.clear_producer_id();
        self.clear_sequence_id();
        self.clear_error();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSendError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSendError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandMessage {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    message_id: ::protobuf::SingularPtrField<MessageIdData>,
    redelivery_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandMessage {
    pub fn new() -> CommandMessage {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required .pulsar.proto.MessageIdData message_id = 2;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| MessageIdData::default_instance())
    }

    // optional uint32 redelivery_count = 3;

    pub fn clear_redelivery_count(&mut self) {
        self.redelivery_count = ::std::option::Option::None;
    }

    pub fn has_redelivery_count(&self) -> bool {
        self.redelivery_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redelivery_count(&mut self, v: u32) {
        self.redelivery_count = ::std::option::Option::Some(v);
    }

    pub fn get_redelivery_count(&self) -> u32 {
        self.redelivery_count.unwrap_or(0u32)
    }
}

impl ::protobuf::Message for CommandMessage {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.message_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.redelivery_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.redelivery_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.redelivery_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandMessage {
        CommandMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandMessage| { &m.consumer_id },
                    |m: &mut CommandMessage| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "message_id",
                    |m: &CommandMessage| { &m.message_id },
                    |m: &mut CommandMessage| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "redelivery_count",
                    |m: &CommandMessage| { &m.redelivery_count },
                    |m: &mut CommandMessage| { &mut m.redelivery_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandMessage>(
                    "CommandMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandMessage {
        static mut instance: ::protobuf::lazy::Lazy<CommandMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandMessage,
        };
        unsafe {
            instance.get(CommandMessage::new)
        }
    }
}

impl ::protobuf::Clear for CommandMessage {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_message_id();
        self.clear_redelivery_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandAck {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    ack_type: ::std::option::Option<CommandAck_AckType>,
    message_id: ::protobuf::RepeatedField<MessageIdData>,
    validation_error: ::std::option::Option<CommandAck_ValidationError>,
    properties: ::protobuf::RepeatedField<KeyLongValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandAck {
    pub fn new() -> CommandAck {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required .pulsar.proto.CommandAck.AckType ack_type = 2;

    pub fn clear_ack_type(&mut self) {
        self.ack_type = ::std::option::Option::None;
    }

    pub fn has_ack_type(&self) -> bool {
        self.ack_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_type(&mut self, v: CommandAck_AckType) {
        self.ack_type = ::std::option::Option::Some(v);
    }

    pub fn get_ack_type(&self) -> CommandAck_AckType {
        self.ack_type.unwrap_or(CommandAck_AckType::Individual)
    }

    // repeated .pulsar.proto.MessageIdData message_id = 3;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: ::protobuf::RepeatedField<MessageIdData>) {
        self.message_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_id(&mut self) -> &mut ::protobuf::RepeatedField<MessageIdData> {
        &mut self.message_id
    }

    // Take field
    pub fn take_message_id(&mut self) -> ::protobuf::RepeatedField<MessageIdData> {
        ::std::mem::replace(&mut self.message_id, ::protobuf::RepeatedField::new())
    }

    pub fn get_message_id(&self) -> &[MessageIdData] {
        &self.message_id
    }

    // optional .pulsar.proto.CommandAck.ValidationError validation_error = 4;

    pub fn clear_validation_error(&mut self) {
        self.validation_error = ::std::option::Option::None;
    }

    pub fn has_validation_error(&self) -> bool {
        self.validation_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validation_error(&mut self, v: CommandAck_ValidationError) {
        self.validation_error = ::std::option::Option::Some(v);
    }

    pub fn get_validation_error(&self) -> CommandAck_ValidationError {
        self.validation_error.unwrap_or(CommandAck_ValidationError::UncompressedSizeCorruption)
    }

    // repeated .pulsar.proto.KeyLongValue properties = 5;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<KeyLongValue>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<KeyLongValue> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<KeyLongValue> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[KeyLongValue] {
        &self.properties
    }
}

impl ::protobuf::Message for CommandAck {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.ack_type.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ack_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.message_id)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.validation_error, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ack_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.message_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.validation_error {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ack_type {
            os.write_enum(2, v.value())?;
        }
        for v in &self.message_id {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.validation_error {
            os.write_enum(4, v.value())?;
        }
        for v in &self.properties {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandAck {
        CommandAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandAck| { &m.consumer_id },
                    |m: &mut CommandAck| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandAck_AckType>>(
                    "ack_type",
                    |m: &CommandAck| { &m.ack_type },
                    |m: &mut CommandAck| { &mut m.ack_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "message_id",
                    |m: &CommandAck| { &m.message_id },
                    |m: &mut CommandAck| { &mut m.message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandAck_ValidationError>>(
                    "validation_error",
                    |m: &CommandAck| { &m.validation_error },
                    |m: &mut CommandAck| { &mut m.validation_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyLongValue>>(
                    "properties",
                    |m: &CommandAck| { &m.properties },
                    |m: &mut CommandAck| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandAck>(
                    "CommandAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandAck {
        static mut instance: ::protobuf::lazy::Lazy<CommandAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandAck,
        };
        unsafe {
            instance.get(CommandAck::new)
        }
    }
}

impl ::protobuf::Clear for CommandAck {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_ack_type();
        self.clear_message_id();
        self.clear_validation_error();
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandAck_AckType {
    Individual = 0,
    Cumulative = 1,
}

impl ::protobuf::ProtobufEnum for CommandAck_AckType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandAck_AckType> {
        match value {
            0 => ::std::option::Option::Some(CommandAck_AckType::Individual),
            1 => ::std::option::Option::Some(CommandAck_AckType::Cumulative),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandAck_AckType] = &[
            CommandAck_AckType::Individual,
            CommandAck_AckType::Cumulative,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandAck_AckType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandAck_AckType {
}

impl ::std::default::Default for CommandAck_AckType {
    fn default() -> Self {
        CommandAck_AckType::Individual
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck_AckType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandAck_ValidationError {
    UncompressedSizeCorruption = 0,
    DecompressionError = 1,
    ChecksumMismatch = 2,
    BatchDeSerializeError = 3,
    DecryptionError = 4,
}

impl ::protobuf::ProtobufEnum for CommandAck_ValidationError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandAck_ValidationError> {
        match value {
            0 => ::std::option::Option::Some(CommandAck_ValidationError::UncompressedSizeCorruption),
            1 => ::std::option::Option::Some(CommandAck_ValidationError::DecompressionError),
            2 => ::std::option::Option::Some(CommandAck_ValidationError::ChecksumMismatch),
            3 => ::std::option::Option::Some(CommandAck_ValidationError::BatchDeSerializeError),
            4 => ::std::option::Option::Some(CommandAck_ValidationError::DecryptionError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandAck_ValidationError] = &[
            CommandAck_ValidationError::UncompressedSizeCorruption,
            CommandAck_ValidationError::DecompressionError,
            CommandAck_ValidationError::ChecksumMismatch,
            CommandAck_ValidationError::BatchDeSerializeError,
            CommandAck_ValidationError::DecryptionError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandAck_ValidationError", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandAck_ValidationError {
}

impl ::std::default::Default for CommandAck_ValidationError {
    fn default() -> Self {
        CommandAck_ValidationError::UncompressedSizeCorruption
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAck_ValidationError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandActiveConsumerChange {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    is_active: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandActiveConsumerChange {
    pub fn new() -> CommandActiveConsumerChange {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // optional bool is_active = 2;

    pub fn clear_is_active(&mut self) {
        self.is_active = ::std::option::Option::None;
    }

    pub fn has_is_active(&self) -> bool {
        self.is_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = ::std::option::Option::Some(v);
    }

    pub fn get_is_active(&self) -> bool {
        self.is_active.unwrap_or(false)
    }
}

impl ::protobuf::Message for CommandActiveConsumerChange {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_active {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_active {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandActiveConsumerChange {
        CommandActiveConsumerChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandActiveConsumerChange| { &m.consumer_id },
                    |m: &mut CommandActiveConsumerChange| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_active",
                    |m: &CommandActiveConsumerChange| { &m.is_active },
                    |m: &mut CommandActiveConsumerChange| { &mut m.is_active },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandActiveConsumerChange>(
                    "CommandActiveConsumerChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandActiveConsumerChange {
        static mut instance: ::protobuf::lazy::Lazy<CommandActiveConsumerChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandActiveConsumerChange,
        };
        unsafe {
            instance.get(CommandActiveConsumerChange::new)
        }
    }
}

impl ::protobuf::Clear for CommandActiveConsumerChange {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_is_active();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandActiveConsumerChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandActiveConsumerChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandFlow {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    messagePermits: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandFlow {
    pub fn new() -> CommandFlow {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint32 messagePermits = 2;

    pub fn clear_messagePermits(&mut self) {
        self.messagePermits = ::std::option::Option::None;
    }

    pub fn has_messagePermits(&self) -> bool {
        self.messagePermits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagePermits(&mut self, v: u32) {
        self.messagePermits = ::std::option::Option::Some(v);
    }

    pub fn get_messagePermits(&self) -> u32 {
        self.messagePermits.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandFlow {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.messagePermits.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.messagePermits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.messagePermits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.messagePermits {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandFlow {
        CommandFlow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandFlow| { &m.consumer_id },
                    |m: &mut CommandFlow| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "messagePermits",
                    |m: &CommandFlow| { &m.messagePermits },
                    |m: &mut CommandFlow| { &mut m.messagePermits },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandFlow>(
                    "CommandFlow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandFlow {
        static mut instance: ::protobuf::lazy::Lazy<CommandFlow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandFlow,
        };
        unsafe {
            instance.get(CommandFlow::new)
        }
    }
}

impl ::protobuf::Clear for CommandFlow {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_messagePermits();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandFlow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandFlow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandUnsubscribe {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandUnsubscribe {
    pub fn new() -> CommandUnsubscribe {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandUnsubscribe {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandUnsubscribe {
        CommandUnsubscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandUnsubscribe| { &m.consumer_id },
                    |m: &mut CommandUnsubscribe| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandUnsubscribe| { &m.request_id },
                    |m: &mut CommandUnsubscribe| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandUnsubscribe>(
                    "CommandUnsubscribe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandUnsubscribe {
        static mut instance: ::protobuf::lazy::Lazy<CommandUnsubscribe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandUnsubscribe,
        };
        unsafe {
            instance.get(CommandUnsubscribe::new)
        }
    }
}

impl ::protobuf::Clear for CommandUnsubscribe {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandUnsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandUnsubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSeek {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    message_id: ::protobuf::SingularPtrField<MessageIdData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSeek {
    pub fn new() -> CommandSeek {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional .pulsar.proto.MessageIdData message_id = 3;

    pub fn clear_message_id(&mut self) {
        self.message_id.clear();
    }

    pub fn has_message_id(&self) -> bool {
        self.message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_id(&mut self, v: MessageIdData) {
        self.message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_id(&mut self) -> &mut MessageIdData {
        if self.message_id.is_none() {
            self.message_id.set_default();
        }
        self.message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_id(&mut self) -> MessageIdData {
        self.message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    pub fn get_message_id(&self) -> &MessageIdData {
        self.message_id.as_ref().unwrap_or_else(|| MessageIdData::default_instance())
    }
}

impl ::protobuf::Message for CommandSeek {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.message_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSeek {
        CommandSeek::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandSeek| { &m.consumer_id },
                    |m: &mut CommandSeek| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandSeek| { &m.request_id },
                    |m: &mut CommandSeek| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "message_id",
                    |m: &CommandSeek| { &m.message_id },
                    |m: &mut CommandSeek| { &mut m.message_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSeek>(
                    "CommandSeek",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSeek {
        static mut instance: ::protobuf::lazy::Lazy<CommandSeek> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSeek,
        };
        unsafe {
            instance.get(CommandSeek::new)
        }
    }
}

impl ::protobuf::Clear for CommandSeek {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_request_id();
        self.clear_message_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSeek {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSeek {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandReachedEndOfTopic {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandReachedEndOfTopic {
    pub fn new() -> CommandReachedEndOfTopic {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandReachedEndOfTopic {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandReachedEndOfTopic {
        CommandReachedEndOfTopic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandReachedEndOfTopic| { &m.consumer_id },
                    |m: &mut CommandReachedEndOfTopic| { &mut m.consumer_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandReachedEndOfTopic>(
                    "CommandReachedEndOfTopic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandReachedEndOfTopic {
        static mut instance: ::protobuf::lazy::Lazy<CommandReachedEndOfTopic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandReachedEndOfTopic,
        };
        unsafe {
            instance.get(CommandReachedEndOfTopic::new)
        }
    }
}

impl ::protobuf::Clear for CommandReachedEndOfTopic {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandReachedEndOfTopic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandReachedEndOfTopic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandCloseProducer {
    // message fields
    producer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandCloseProducer {
    pub fn new() -> CommandCloseProducer {
        ::std::default::Default::default()
    }

    // required uint64 producer_id = 1;

    pub fn clear_producer_id(&mut self) {
        self.producer_id = ::std::option::Option::None;
    }

    pub fn has_producer_id(&self) -> bool {
        self.producer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_id(&mut self, v: u64) {
        self.producer_id = ::std::option::Option::Some(v);
    }

    pub fn get_producer_id(&self) -> u64 {
        self.producer_id.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandCloseProducer {
    fn is_initialized(&self) -> bool {
        if self.producer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.producer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.producer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.producer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandCloseProducer {
        CommandCloseProducer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "producer_id",
                    |m: &CommandCloseProducer| { &m.producer_id },
                    |m: &mut CommandCloseProducer| { &mut m.producer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandCloseProducer| { &m.request_id },
                    |m: &mut CommandCloseProducer| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandCloseProducer>(
                    "CommandCloseProducer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandCloseProducer {
        static mut instance: ::protobuf::lazy::Lazy<CommandCloseProducer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandCloseProducer,
        };
        unsafe {
            instance.get(CommandCloseProducer::new)
        }
    }
}

impl ::protobuf::Clear for CommandCloseProducer {
    fn clear(&mut self) {
        self.clear_producer_id();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandCloseProducer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandCloseProducer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandCloseConsumer {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandCloseConsumer {
    pub fn new() -> CommandCloseConsumer {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandCloseConsumer {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandCloseConsumer {
        CommandCloseConsumer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandCloseConsumer| { &m.consumer_id },
                    |m: &mut CommandCloseConsumer| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandCloseConsumer| { &m.request_id },
                    |m: &mut CommandCloseConsumer| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandCloseConsumer>(
                    "CommandCloseConsumer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandCloseConsumer {
        static mut instance: ::protobuf::lazy::Lazy<CommandCloseConsumer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandCloseConsumer,
        };
        unsafe {
            instance.get(CommandCloseConsumer::new)
        }
    }
}

impl ::protobuf::Clear for CommandCloseConsumer {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandCloseConsumer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandCloseConsumer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandRedeliverUnacknowledgedMessages {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    message_ids: ::protobuf::RepeatedField<MessageIdData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandRedeliverUnacknowledgedMessages {
    pub fn new() -> CommandRedeliverUnacknowledgedMessages {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // repeated .pulsar.proto.MessageIdData message_ids = 2;

    pub fn clear_message_ids(&mut self) {
        self.message_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_message_ids(&mut self, v: ::protobuf::RepeatedField<MessageIdData>) {
        self.message_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_message_ids(&mut self) -> &mut ::protobuf::RepeatedField<MessageIdData> {
        &mut self.message_ids
    }

    // Take field
    pub fn take_message_ids(&mut self) -> ::protobuf::RepeatedField<MessageIdData> {
        ::std::mem::replace(&mut self.message_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_message_ids(&self) -> &[MessageIdData] {
        &self.message_ids
    }
}

impl ::protobuf::Message for CommandRedeliverUnacknowledgedMessages {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        for v in &self.message_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.message_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.message_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.message_ids {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandRedeliverUnacknowledgedMessages {
        CommandRedeliverUnacknowledgedMessages::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandRedeliverUnacknowledgedMessages| { &m.consumer_id },
                    |m: &mut CommandRedeliverUnacknowledgedMessages| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "message_ids",
                    |m: &CommandRedeliverUnacknowledgedMessages| { &m.message_ids },
                    |m: &mut CommandRedeliverUnacknowledgedMessages| { &mut m.message_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandRedeliverUnacknowledgedMessages>(
                    "CommandRedeliverUnacknowledgedMessages",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandRedeliverUnacknowledgedMessages {
        static mut instance: ::protobuf::lazy::Lazy<CommandRedeliverUnacknowledgedMessages> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandRedeliverUnacknowledgedMessages,
        };
        unsafe {
            instance.get(CommandRedeliverUnacknowledgedMessages::new)
        }
    }
}

impl ::protobuf::Clear for CommandRedeliverUnacknowledgedMessages {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_message_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandRedeliverUnacknowledgedMessages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandRedeliverUnacknowledgedMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandSuccess {
    // message fields
    request_id: ::std::option::Option<u64>,
    schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandSuccess {
    pub fn new() -> CommandSuccess {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional .pulsar.proto.Schema schema = 2;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }
}

impl ::protobuf::Message for CommandSuccess {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandSuccess {
        CommandSuccess::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandSuccess| { &m.request_id },
                    |m: &mut CommandSuccess| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &CommandSuccess| { &m.schema },
                    |m: &mut CommandSuccess| { &mut m.schema },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandSuccess>(
                    "CommandSuccess",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandSuccess {
        static mut instance: ::protobuf::lazy::Lazy<CommandSuccess> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandSuccess,
        };
        unsafe {
            instance.get(CommandSuccess::new)
        }
    }
}

impl ::protobuf::Clear for CommandSuccess {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandSuccess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandSuccess {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandProducerSuccess {
    // message fields
    request_id: ::std::option::Option<u64>,
    producer_name: ::protobuf::SingularField<::std::string::String>,
    last_sequence_id: ::std::option::Option<i64>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandProducerSuccess {
    pub fn new() -> CommandProducerSuccess {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // required string producer_name = 2;

    pub fn clear_producer_name(&mut self) {
        self.producer_name.clear();
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name.set_default();
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int64 last_sequence_id = 3;

    pub fn clear_last_sequence_id(&mut self) {
        self.last_sequence_id = ::std::option::Option::None;
    }

    pub fn has_last_sequence_id(&self) -> bool {
        self.last_sequence_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_sequence_id(&mut self, v: i64) {
        self.last_sequence_id = ::std::option::Option::Some(v);
    }

    pub fn get_last_sequence_id(&self) -> i64 {
        self.last_sequence_id.unwrap_or(-1i64)
    }

    // optional bytes schema_version = 4;

    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CommandProducerSuccess {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.producer_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.producer_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_sequence_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.last_sequence_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.producer_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.last_sequence_id {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandProducerSuccess {
        CommandProducerSuccess::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandProducerSuccess| { &m.request_id },
                    |m: &mut CommandProducerSuccess| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer_name",
                    |m: &CommandProducerSuccess| { &m.producer_name },
                    |m: &mut CommandProducerSuccess| { &mut m.producer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_sequence_id",
                    |m: &CommandProducerSuccess| { &m.last_sequence_id },
                    |m: &mut CommandProducerSuccess| { &mut m.last_sequence_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "schema_version",
                    |m: &CommandProducerSuccess| { &m.schema_version },
                    |m: &mut CommandProducerSuccess| { &mut m.schema_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandProducerSuccess>(
                    "CommandProducerSuccess",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandProducerSuccess {
        static mut instance: ::protobuf::lazy::Lazy<CommandProducerSuccess> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandProducerSuccess,
        };
        unsafe {
            instance.get(CommandProducerSuccess::new)
        }
    }
}

impl ::protobuf::Clear for CommandProducerSuccess {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_producer_name();
        self.clear_last_sequence_id();
        self.clear_schema_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandProducerSuccess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandProducerSuccess {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandError {
    // message fields
    request_id: ::std::option::Option<u64>,
    error: ::std::option::Option<ServerError>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandError {
    pub fn new() -> CommandError {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // required .pulsar.proto.ServerError error = 2;

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ServerError) {
        self.error = ::std::option::Option::Some(v);
    }

    pub fn get_error(&self) -> ServerError {
        self.error.unwrap_or(ServerError::UnknownError)
    }

    // required string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandError {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.error.is_none() {
            return false;
        }
        if self.message.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandError {
        CommandError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandError| { &m.request_id },
                    |m: &mut CommandError| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error",
                    |m: &CommandError| { &m.error },
                    |m: &mut CommandError| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CommandError| { &m.message },
                    |m: &mut CommandError| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandError>(
                    "CommandError",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandError {
        static mut instance: ::protobuf::lazy::Lazy<CommandError> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandError,
        };
        unsafe {
            instance.get(CommandError::new)
        }
    }
}

impl ::protobuf::Clear for CommandError {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_error();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPing {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandPing {
    pub fn new() -> CommandPing {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPing {
        CommandPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CommandPing>(
                    "CommandPing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandPing {
        static mut instance: ::protobuf::lazy::Lazy<CommandPing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandPing,
        };
        unsafe {
            instance.get(CommandPing::new)
        }
    }
}

impl ::protobuf::Clear for CommandPing {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandPong {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandPong {
    pub fn new() -> CommandPong {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommandPong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandPong {
        CommandPong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CommandPong>(
                    "CommandPong",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandPong {
        static mut instance: ::protobuf::lazy::Lazy<CommandPong> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandPong,
        };
        unsafe {
            instance.get(CommandPong::new)
        }
    }
}

impl ::protobuf::Clear for CommandPong {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandPong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandPong {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandConsumerStats {
    // message fields
    request_id: ::std::option::Option<u64>,
    consumer_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandConsumerStats {
    pub fn new() -> CommandConsumerStats {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // required uint64 consumer_id = 4;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandConsumerStats {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.consumer_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.consumer_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConsumerStats {
        CommandConsumerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandConsumerStats| { &m.request_id },
                    |m: &mut CommandConsumerStats| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandConsumerStats| { &m.consumer_id },
                    |m: &mut CommandConsumerStats| { &mut m.consumer_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandConsumerStats>(
                    "CommandConsumerStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandConsumerStats {
        static mut instance: ::protobuf::lazy::Lazy<CommandConsumerStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandConsumerStats,
        };
        unsafe {
            instance.get(CommandConsumerStats::new)
        }
    }
}

impl ::protobuf::Clear for CommandConsumerStats {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_consumer_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandConsumerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConsumerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandConsumerStatsResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    error_code: ::std::option::Option<ServerError>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    msgRateOut: ::std::option::Option<f64>,
    msgThroughputOut: ::std::option::Option<f64>,
    msgRateRedeliver: ::std::option::Option<f64>,
    consumerName: ::protobuf::SingularField<::std::string::String>,
    availablePermits: ::std::option::Option<u64>,
    unackedMessages: ::std::option::Option<u64>,
    blockedConsumerOnUnackedMsgs: ::std::option::Option<bool>,
    address: ::protobuf::SingularField<::std::string::String>,
    connectedSince: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    msgRateExpired: ::std::option::Option<f64>,
    msgBacklog: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandConsumerStatsResponse {
    pub fn new() -> CommandConsumerStatsResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional .pulsar.proto.ServerError error_code = 2;

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ServerError) {
        self.error_code = ::std::option::Option::Some(v);
    }

    pub fn get_error_code(&self) -> ServerError {
        self.error_code.unwrap_or(ServerError::UnknownError)
    }

    // optional string error_message = 3;

    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double msgRateOut = 4;

    pub fn clear_msgRateOut(&mut self) {
        self.msgRateOut = ::std::option::Option::None;
    }

    pub fn has_msgRateOut(&self) -> bool {
        self.msgRateOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateOut(&mut self, v: f64) {
        self.msgRateOut = ::std::option::Option::Some(v);
    }

    pub fn get_msgRateOut(&self) -> f64 {
        self.msgRateOut.unwrap_or(0.)
    }

    // optional double msgThroughputOut = 5;

    pub fn clear_msgThroughputOut(&mut self) {
        self.msgThroughputOut = ::std::option::Option::None;
    }

    pub fn has_msgThroughputOut(&self) -> bool {
        self.msgThroughputOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgThroughputOut(&mut self, v: f64) {
        self.msgThroughputOut = ::std::option::Option::Some(v);
    }

    pub fn get_msgThroughputOut(&self) -> f64 {
        self.msgThroughputOut.unwrap_or(0.)
    }

    // optional double msgRateRedeliver = 6;

    pub fn clear_msgRateRedeliver(&mut self) {
        self.msgRateRedeliver = ::std::option::Option::None;
    }

    pub fn has_msgRateRedeliver(&self) -> bool {
        self.msgRateRedeliver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateRedeliver(&mut self, v: f64) {
        self.msgRateRedeliver = ::std::option::Option::Some(v);
    }

    pub fn get_msgRateRedeliver(&self) -> f64 {
        self.msgRateRedeliver.unwrap_or(0.)
    }

    // optional string consumerName = 7;

    pub fn clear_consumerName(&mut self) {
        self.consumerName.clear();
    }

    pub fn has_consumerName(&self) -> bool {
        self.consumerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerName(&mut self, v: ::std::string::String) {
        self.consumerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerName(&mut self) -> &mut ::std::string::String {
        if self.consumerName.is_none() {
            self.consumerName.set_default();
        }
        self.consumerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerName(&mut self) -> ::std::string::String {
        self.consumerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_consumerName(&self) -> &str {
        match self.consumerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 availablePermits = 8;

    pub fn clear_availablePermits(&mut self) {
        self.availablePermits = ::std::option::Option::None;
    }

    pub fn has_availablePermits(&self) -> bool {
        self.availablePermits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availablePermits(&mut self, v: u64) {
        self.availablePermits = ::std::option::Option::Some(v);
    }

    pub fn get_availablePermits(&self) -> u64 {
        self.availablePermits.unwrap_or(0)
    }

    // optional uint64 unackedMessages = 9;

    pub fn clear_unackedMessages(&mut self) {
        self.unackedMessages = ::std::option::Option::None;
    }

    pub fn has_unackedMessages(&self) -> bool {
        self.unackedMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unackedMessages(&mut self, v: u64) {
        self.unackedMessages = ::std::option::Option::Some(v);
    }

    pub fn get_unackedMessages(&self) -> u64 {
        self.unackedMessages.unwrap_or(0)
    }

    // optional bool blockedConsumerOnUnackedMsgs = 10;

    pub fn clear_blockedConsumerOnUnackedMsgs(&mut self) {
        self.blockedConsumerOnUnackedMsgs = ::std::option::Option::None;
    }

    pub fn has_blockedConsumerOnUnackedMsgs(&self) -> bool {
        self.blockedConsumerOnUnackedMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockedConsumerOnUnackedMsgs(&mut self, v: bool) {
        self.blockedConsumerOnUnackedMsgs = ::std::option::Option::Some(v);
    }

    pub fn get_blockedConsumerOnUnackedMsgs(&self) -> bool {
        self.blockedConsumerOnUnackedMsgs.unwrap_or(false)
    }

    // optional string address = 11;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string connectedSince = 12;

    pub fn clear_connectedSince(&mut self) {
        self.connectedSince.clear();
    }

    pub fn has_connectedSince(&self) -> bool {
        self.connectedSince.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectedSince(&mut self, v: ::std::string::String) {
        self.connectedSince = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connectedSince(&mut self) -> &mut ::std::string::String {
        if self.connectedSince.is_none() {
            self.connectedSince.set_default();
        }
        self.connectedSince.as_mut().unwrap()
    }

    // Take field
    pub fn take_connectedSince(&mut self) -> ::std::string::String {
        self.connectedSince.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_connectedSince(&self) -> &str {
        match self.connectedSince.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string type = 13;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional double msgRateExpired = 14;

    pub fn clear_msgRateExpired(&mut self) {
        self.msgRateExpired = ::std::option::Option::None;
    }

    pub fn has_msgRateExpired(&self) -> bool {
        self.msgRateExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgRateExpired(&mut self, v: f64) {
        self.msgRateExpired = ::std::option::Option::Some(v);
    }

    pub fn get_msgRateExpired(&self) -> f64 {
        self.msgRateExpired.unwrap_or(0.)
    }

    // optional uint64 msgBacklog = 15;

    pub fn clear_msgBacklog(&mut self) {
        self.msgBacklog = ::std::option::Option::None;
    }

    pub fn has_msgBacklog(&self) -> bool {
        self.msgBacklog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgBacklog(&mut self, v: u64) {
        self.msgBacklog = ::std::option::Option::Some(v);
    }

    pub fn get_msgBacklog(&self) -> u64 {
        self.msgBacklog.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandConsumerStatsResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateOut = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgThroughputOut = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateRedeliver = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.consumerName)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.availablePermits = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unackedMessages = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blockedConsumerOnUnackedMsgs = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connectedSince)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.msgRateExpired = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msgBacklog = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.msgRateOut {
            my_size += 9;
        }
        if let Some(v) = self.msgThroughputOut {
            my_size += 9;
        }
        if let Some(v) = self.msgRateRedeliver {
            my_size += 9;
        }
        if let Some(ref v) = self.consumerName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.availablePermits {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unackedMessages {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockedConsumerOnUnackedMsgs {
            my_size += 2;
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.connectedSince.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.msgRateExpired {
            my_size += 9;
        }
        if let Some(v) = self.msgBacklog {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.msgRateOut {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.msgThroughputOut {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.msgRateRedeliver {
            os.write_double(6, v)?;
        }
        if let Some(ref v) = self.consumerName.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.availablePermits {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.unackedMessages {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.blockedConsumerOnUnackedMsgs {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.connectedSince.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.msgRateExpired {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.msgBacklog {
            os.write_uint64(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandConsumerStatsResponse {
        CommandConsumerStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandConsumerStatsResponse| { &m.request_id },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error_code",
                    |m: &CommandConsumerStatsResponse| { &m.error_code },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.error_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_message",
                    |m: &CommandConsumerStatsResponse| { &m.error_message },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.error_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "msgRateOut",
                    |m: &CommandConsumerStatsResponse| { &m.msgRateOut },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.msgRateOut },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "msgThroughputOut",
                    |m: &CommandConsumerStatsResponse| { &m.msgThroughputOut },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.msgThroughputOut },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "msgRateRedeliver",
                    |m: &CommandConsumerStatsResponse| { &m.msgRateRedeliver },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.msgRateRedeliver },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "consumerName",
                    |m: &CommandConsumerStatsResponse| { &m.consumerName },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.consumerName },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "availablePermits",
                    |m: &CommandConsumerStatsResponse| { &m.availablePermits },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.availablePermits },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "unackedMessages",
                    |m: &CommandConsumerStatsResponse| { &m.unackedMessages },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.unackedMessages },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blockedConsumerOnUnackedMsgs",
                    |m: &CommandConsumerStatsResponse| { &m.blockedConsumerOnUnackedMsgs },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.blockedConsumerOnUnackedMsgs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &CommandConsumerStatsResponse| { &m.address },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "connectedSince",
                    |m: &CommandConsumerStatsResponse| { &m.connectedSince },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.connectedSince },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &CommandConsumerStatsResponse| { &m.field_type },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "msgRateExpired",
                    |m: &CommandConsumerStatsResponse| { &m.msgRateExpired },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.msgRateExpired },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "msgBacklog",
                    |m: &CommandConsumerStatsResponse| { &m.msgBacklog },
                    |m: &mut CommandConsumerStatsResponse| { &mut m.msgBacklog },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandConsumerStatsResponse>(
                    "CommandConsumerStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandConsumerStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandConsumerStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandConsumerStatsResponse,
        };
        unsafe {
            instance.get(CommandConsumerStatsResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandConsumerStatsResponse {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_error_code();
        self.clear_error_message();
        self.clear_msgRateOut();
        self.clear_msgThroughputOut();
        self.clear_msgRateRedeliver();
        self.clear_consumerName();
        self.clear_availablePermits();
        self.clear_unackedMessages();
        self.clear_blockedConsumerOnUnackedMsgs();
        self.clear_address();
        self.clear_connectedSince();
        self.clear_field_type();
        self.clear_msgRateExpired();
        self.clear_msgBacklog();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandConsumerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandConsumerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetLastMessageId {
    // message fields
    consumer_id: ::std::option::Option<u64>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetLastMessageId {
    pub fn new() -> CommandGetLastMessageId {
        ::std::default::Default::default()
    }

    // required uint64 consumer_id = 1;

    pub fn clear_consumer_id(&mut self) {
        self.consumer_id = ::std::option::Option::None;
    }

    pub fn has_consumer_id(&self) -> bool {
        self.consumer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumer_id(&mut self, v: u64) {
        self.consumer_id = ::std::option::Option::Some(v);
    }

    pub fn get_consumer_id(&self) -> u64 {
        self.consumer_id.unwrap_or(0)
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandGetLastMessageId {
    fn is_initialized(&self) -> bool {
        if self.consumer_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumer_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.consumer_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.consumer_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetLastMessageId {
        CommandGetLastMessageId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumer_id",
                    |m: &CommandGetLastMessageId| { &m.consumer_id },
                    |m: &mut CommandGetLastMessageId| { &mut m.consumer_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetLastMessageId| { &m.request_id },
                    |m: &mut CommandGetLastMessageId| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetLastMessageId>(
                    "CommandGetLastMessageId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetLastMessageId {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetLastMessageId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetLastMessageId,
        };
        unsafe {
            instance.get(CommandGetLastMessageId::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetLastMessageId {
    fn clear(&mut self) {
        self.clear_consumer_id();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetLastMessageId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetLastMessageId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetLastMessageIdResponse {
    // message fields
    last_message_id: ::protobuf::SingularPtrField<MessageIdData>,
    request_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetLastMessageIdResponse {
    pub fn new() -> CommandGetLastMessageIdResponse {
        ::std::default::Default::default()
    }

    // required .pulsar.proto.MessageIdData last_message_id = 1;

    pub fn clear_last_message_id(&mut self) {
        self.last_message_id.clear();
    }

    pub fn has_last_message_id(&self) -> bool {
        self.last_message_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message_id(&mut self, v: MessageIdData) {
        self.last_message_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message_id(&mut self) -> &mut MessageIdData {
        if self.last_message_id.is_none() {
            self.last_message_id.set_default();
        }
        self.last_message_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message_id(&mut self) -> MessageIdData {
        self.last_message_id.take().unwrap_or_else(|| MessageIdData::new())
    }

    pub fn get_last_message_id(&self) -> &MessageIdData {
        self.last_message_id.as_ref().unwrap_or_else(|| MessageIdData::default_instance())
    }

    // required uint64 request_id = 2;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CommandGetLastMessageIdResponse {
    fn is_initialized(&self) -> bool {
        if self.last_message_id.is_none() {
            return false;
        }
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.last_message_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_message_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.last_message_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.last_message_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetLastMessageIdResponse {
        CommandGetLastMessageIdResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageIdData>>(
                    "last_message_id",
                    |m: &CommandGetLastMessageIdResponse| { &m.last_message_id },
                    |m: &mut CommandGetLastMessageIdResponse| { &mut m.last_message_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetLastMessageIdResponse| { &m.request_id },
                    |m: &mut CommandGetLastMessageIdResponse| { &mut m.request_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetLastMessageIdResponse>(
                    "CommandGetLastMessageIdResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetLastMessageIdResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetLastMessageIdResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetLastMessageIdResponse,
        };
        unsafe {
            instance.get(CommandGetLastMessageIdResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetLastMessageIdResponse {
    fn clear(&mut self) {
        self.clear_last_message_id();
        self.clear_request_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetLastMessageIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetLastMessageIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetTopicsOfNamespace {
    // message fields
    request_id: ::std::option::Option<u64>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<CommandGetTopicsOfNamespace_Mode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetTopicsOfNamespace {
    pub fn new() -> CommandGetTopicsOfNamespace {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // required string namespace = 2;

    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace.Mode mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: CommandGetTopicsOfNamespace_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> CommandGetTopicsOfNamespace_Mode {
        self.mode.unwrap_or(CommandGetTopicsOfNamespace_Mode::PERSISTENT)
    }
}

impl ::protobuf::Message for CommandGetTopicsOfNamespace {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.namespace.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTopicsOfNamespace {
        CommandGetTopicsOfNamespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetTopicsOfNamespace| { &m.request_id },
                    |m: &mut CommandGetTopicsOfNamespace| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &CommandGetTopicsOfNamespace| { &m.namespace },
                    |m: &mut CommandGetTopicsOfNamespace| { &mut m.namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandGetTopicsOfNamespace_Mode>>(
                    "mode",
                    |m: &CommandGetTopicsOfNamespace| { &m.mode },
                    |m: &mut CommandGetTopicsOfNamespace| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetTopicsOfNamespace>(
                    "CommandGetTopicsOfNamespace",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetTopicsOfNamespace {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetTopicsOfNamespace> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetTopicsOfNamespace,
        };
        unsafe {
            instance.get(CommandGetTopicsOfNamespace::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetTopicsOfNamespace {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_namespace();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetTopicsOfNamespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespace {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandGetTopicsOfNamespace_Mode {
    PERSISTENT = 0,
    NON_PERSISTENT = 1,
    ALL = 2,
}

impl ::protobuf::ProtobufEnum for CommandGetTopicsOfNamespace_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandGetTopicsOfNamespace_Mode> {
        match value {
            0 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::PERSISTENT),
            1 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::NON_PERSISTENT),
            2 => ::std::option::Option::Some(CommandGetTopicsOfNamespace_Mode::ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandGetTopicsOfNamespace_Mode] = &[
            CommandGetTopicsOfNamespace_Mode::PERSISTENT,
            CommandGetTopicsOfNamespace_Mode::NON_PERSISTENT,
            CommandGetTopicsOfNamespace_Mode::ALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandGetTopicsOfNamespace_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandGetTopicsOfNamespace_Mode {
}

impl ::std::default::Default for CommandGetTopicsOfNamespace_Mode {
    fn default() -> Self {
        CommandGetTopicsOfNamespace_Mode::PERSISTENT
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespace_Mode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetTopicsOfNamespaceResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    topics: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetTopicsOfNamespaceResponse {
    pub fn new() -> CommandGetTopicsOfNamespaceResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // repeated string topics = 2;

    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    pub fn get_topics(&self) -> &[::std::string::String] {
        &self.topics
    }
}

impl ::protobuf::Message for CommandGetTopicsOfNamespaceResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.topics {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetTopicsOfNamespaceResponse {
        CommandGetTopicsOfNamespaceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetTopicsOfNamespaceResponse| { &m.request_id },
                    |m: &mut CommandGetTopicsOfNamespaceResponse| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topics",
                    |m: &CommandGetTopicsOfNamespaceResponse| { &m.topics },
                    |m: &mut CommandGetTopicsOfNamespaceResponse| { &mut m.topics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetTopicsOfNamespaceResponse>(
                    "CommandGetTopicsOfNamespaceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetTopicsOfNamespaceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetTopicsOfNamespaceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetTopicsOfNamespaceResponse,
        };
        unsafe {
            instance.get(CommandGetTopicsOfNamespaceResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetTopicsOfNamespaceResponse {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_topics();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetTopicsOfNamespaceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetTopicsOfNamespaceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetSchema {
    // message fields
    request_id: ::std::option::Option<u64>,
    topic: ::protobuf::SingularField<::std::string::String>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetSchema {
    pub fn new() -> CommandGetSchema {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // required string topic = 2;

    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    pub fn has_topic(&self) -> bool {
        self.topic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        if self.topic.is_none() {
            self.topic.set_default();
        }
        self.topic.as_mut().unwrap()
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        self.topic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topic(&self) -> &str {
        match self.topic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes schema_version = 3;

    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CommandGetSchema {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.topic.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.topic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.topic.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetSchema {
        CommandGetSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetSchema| { &m.request_id },
                    |m: &mut CommandGetSchema| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topic",
                    |m: &CommandGetSchema| { &m.topic },
                    |m: &mut CommandGetSchema| { &mut m.topic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "schema_version",
                    |m: &CommandGetSchema| { &m.schema_version },
                    |m: &mut CommandGetSchema| { &mut m.schema_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetSchema>(
                    "CommandGetSchema",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetSchema {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetSchema> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetSchema,
        };
        unsafe {
            instance.get(CommandGetSchema::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetSchema {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_topic();
        self.clear_schema_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommandGetSchemaResponse {
    // message fields
    request_id: ::std::option::Option<u64>,
    error_code: ::std::option::Option<ServerError>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    schema: ::protobuf::SingularPtrField<Schema>,
    schema_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommandGetSchemaResponse {
    pub fn new() -> CommandGetSchemaResponse {
        ::std::default::Default::default()
    }

    // required uint64 request_id = 1;

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    pub fn get_request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    // optional .pulsar.proto.ServerError error_code = 2;

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ServerError) {
        self.error_code = ::std::option::Option::Some(v);
    }

    pub fn get_error_code(&self) -> ServerError {
        self.error_code.unwrap_or(ServerError::UnknownError)
    }

    // optional string error_message = 3;

    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .pulsar.proto.Schema schema = 4;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // optional bytes schema_version = 5;

    pub fn clear_schema_version(&mut self) {
        self.schema_version.clear();
    }

    pub fn has_schema_version(&self) -> bool {
        self.schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.schema_version.is_none() {
            self.schema_version.set_default();
        }
        self.schema_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema_version(&mut self) -> ::std::vec::Vec<u8> {
        self.schema_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema_version(&self) -> &[u8] {
        match self.schema_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CommandGetSchemaResponse {
    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.request_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.error_code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.request_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.schema_version.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandGetSchemaResponse {
        CommandGetSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "request_id",
                    |m: &CommandGetSchemaResponse| { &m.request_id },
                    |m: &mut CommandGetSchemaResponse| { &mut m.request_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerError>>(
                    "error_code",
                    |m: &CommandGetSchemaResponse| { &m.error_code },
                    |m: &mut CommandGetSchemaResponse| { &mut m.error_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_message",
                    |m: &CommandGetSchemaResponse| { &m.error_message },
                    |m: &mut CommandGetSchemaResponse| { &mut m.error_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &CommandGetSchemaResponse| { &m.schema },
                    |m: &mut CommandGetSchemaResponse| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "schema_version",
                    |m: &CommandGetSchemaResponse| { &m.schema_version },
                    |m: &mut CommandGetSchemaResponse| { &mut m.schema_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandGetSchemaResponse>(
                    "CommandGetSchemaResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandGetSchemaResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommandGetSchemaResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandGetSchemaResponse,
        };
        unsafe {
            instance.get(CommandGetSchemaResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommandGetSchemaResponse {
    fn clear(&mut self) {
        self.clear_request_id();
        self.clear_error_code();
        self.clear_error_message();
        self.clear_schema();
        self.clear_schema_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandGetSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandGetSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BaseCommand {
    // message fields
    field_type: ::std::option::Option<BaseCommand_Type>,
    connect: ::protobuf::SingularPtrField<CommandConnect>,
    connected: ::protobuf::SingularPtrField<CommandConnected>,
    subscribe: ::protobuf::SingularPtrField<CommandSubscribe>,
    producer: ::protobuf::SingularPtrField<CommandProducer>,
    send: ::protobuf::SingularPtrField<CommandSend>,
    send_receipt: ::protobuf::SingularPtrField<CommandSendReceipt>,
    send_error: ::protobuf::SingularPtrField<CommandSendError>,
    message: ::protobuf::SingularPtrField<CommandMessage>,
    ack: ::protobuf::SingularPtrField<CommandAck>,
    flow: ::protobuf::SingularPtrField<CommandFlow>,
    unsubscribe: ::protobuf::SingularPtrField<CommandUnsubscribe>,
    success: ::protobuf::SingularPtrField<CommandSuccess>,
    error: ::protobuf::SingularPtrField<CommandError>,
    close_producer: ::protobuf::SingularPtrField<CommandCloseProducer>,
    close_consumer: ::protobuf::SingularPtrField<CommandCloseConsumer>,
    producer_success: ::protobuf::SingularPtrField<CommandProducerSuccess>,
    ping: ::protobuf::SingularPtrField<CommandPing>,
    pong: ::protobuf::SingularPtrField<CommandPong>,
    redeliverUnacknowledgedMessages: ::protobuf::SingularPtrField<CommandRedeliverUnacknowledgedMessages>,
    partitionMetadata: ::protobuf::SingularPtrField<CommandPartitionedTopicMetadata>,
    partitionMetadataResponse: ::protobuf::SingularPtrField<CommandPartitionedTopicMetadataResponse>,
    lookupTopic: ::protobuf::SingularPtrField<CommandLookupTopic>,
    lookupTopicResponse: ::protobuf::SingularPtrField<CommandLookupTopicResponse>,
    consumerStats: ::protobuf::SingularPtrField<CommandConsumerStats>,
    consumerStatsResponse: ::protobuf::SingularPtrField<CommandConsumerStatsResponse>,
    reachedEndOfTopic: ::protobuf::SingularPtrField<CommandReachedEndOfTopic>,
    seek: ::protobuf::SingularPtrField<CommandSeek>,
    getLastMessageId: ::protobuf::SingularPtrField<CommandGetLastMessageId>,
    getLastMessageIdResponse: ::protobuf::SingularPtrField<CommandGetLastMessageIdResponse>,
    active_consumer_change: ::protobuf::SingularPtrField<CommandActiveConsumerChange>,
    getTopicsOfNamespace: ::protobuf::SingularPtrField<CommandGetTopicsOfNamespace>,
    getTopicsOfNamespaceResponse: ::protobuf::SingularPtrField<CommandGetTopicsOfNamespaceResponse>,
    getSchema: ::protobuf::SingularPtrField<CommandGetSchema>,
    getSchemaResponse: ::protobuf::SingularPtrField<CommandGetSchemaResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BaseCommand {
    pub fn new() -> BaseCommand {
        ::std::default::Default::default()
    }

    // required .pulsar.proto.BaseCommand.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BaseCommand_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> BaseCommand_Type {
        self.field_type.unwrap_or(BaseCommand_Type::CONNECT)
    }

    // optional .pulsar.proto.CommandConnect connect = 2;

    pub fn clear_connect(&mut self) {
        self.connect.clear();
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: CommandConnect) {
        self.connect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut CommandConnect {
        if self.connect.is_none() {
            self.connect.set_default();
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> CommandConnect {
        self.connect.take().unwrap_or_else(|| CommandConnect::new())
    }

    pub fn get_connect(&self) -> &CommandConnect {
        self.connect.as_ref().unwrap_or_else(|| CommandConnect::default_instance())
    }

    // optional .pulsar.proto.CommandConnected connected = 3;

    pub fn clear_connected(&mut self) {
        self.connected.clear();
    }

    pub fn has_connected(&self) -> bool {
        self.connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected(&mut self, v: CommandConnected) {
        self.connected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connected(&mut self) -> &mut CommandConnected {
        if self.connected.is_none() {
            self.connected.set_default();
        }
        self.connected.as_mut().unwrap()
    }

    // Take field
    pub fn take_connected(&mut self) -> CommandConnected {
        self.connected.take().unwrap_or_else(|| CommandConnected::new())
    }

    pub fn get_connected(&self) -> &CommandConnected {
        self.connected.as_ref().unwrap_or_else(|| CommandConnected::default_instance())
    }

    // optional .pulsar.proto.CommandSubscribe subscribe = 4;

    pub fn clear_subscribe(&mut self) {
        self.subscribe.clear();
    }

    pub fn has_subscribe(&self) -> bool {
        self.subscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe(&mut self, v: CommandSubscribe) {
        self.subscribe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subscribe(&mut self) -> &mut CommandSubscribe {
        if self.subscribe.is_none() {
            self.subscribe.set_default();
        }
        self.subscribe.as_mut().unwrap()
    }

    // Take field
    pub fn take_subscribe(&mut self) -> CommandSubscribe {
        self.subscribe.take().unwrap_or_else(|| CommandSubscribe::new())
    }

    pub fn get_subscribe(&self) -> &CommandSubscribe {
        self.subscribe.as_ref().unwrap_or_else(|| CommandSubscribe::default_instance())
    }

    // optional .pulsar.proto.CommandProducer producer = 5;

    pub fn clear_producer(&mut self) {
        self.producer.clear();
    }

    pub fn has_producer(&self) -> bool {
        self.producer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer(&mut self, v: CommandProducer) {
        self.producer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer(&mut self) -> &mut CommandProducer {
        if self.producer.is_none() {
            self.producer.set_default();
        }
        self.producer.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer(&mut self) -> CommandProducer {
        self.producer.take().unwrap_or_else(|| CommandProducer::new())
    }

    pub fn get_producer(&self) -> &CommandProducer {
        self.producer.as_ref().unwrap_or_else(|| CommandProducer::default_instance())
    }

    // optional .pulsar.proto.CommandSend send = 6;

    pub fn clear_send(&mut self) {
        self.send.clear();
    }

    pub fn has_send(&self) -> bool {
        self.send.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: CommandSend) {
        self.send = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send(&mut self) -> &mut CommandSend {
        if self.send.is_none() {
            self.send.set_default();
        }
        self.send.as_mut().unwrap()
    }

    // Take field
    pub fn take_send(&mut self) -> CommandSend {
        self.send.take().unwrap_or_else(|| CommandSend::new())
    }

    pub fn get_send(&self) -> &CommandSend {
        self.send.as_ref().unwrap_or_else(|| CommandSend::default_instance())
    }

    // optional .pulsar.proto.CommandSendReceipt send_receipt = 7;

    pub fn clear_send_receipt(&mut self) {
        self.send_receipt.clear();
    }

    pub fn has_send_receipt(&self) -> bool {
        self.send_receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_receipt(&mut self, v: CommandSendReceipt) {
        self.send_receipt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_receipt(&mut self) -> &mut CommandSendReceipt {
        if self.send_receipt.is_none() {
            self.send_receipt.set_default();
        }
        self.send_receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_send_receipt(&mut self) -> CommandSendReceipt {
        self.send_receipt.take().unwrap_or_else(|| CommandSendReceipt::new())
    }

    pub fn get_send_receipt(&self) -> &CommandSendReceipt {
        self.send_receipt.as_ref().unwrap_or_else(|| CommandSendReceipt::default_instance())
    }

    // optional .pulsar.proto.CommandSendError send_error = 8;

    pub fn clear_send_error(&mut self) {
        self.send_error.clear();
    }

    pub fn has_send_error(&self) -> bool {
        self.send_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_error(&mut self, v: CommandSendError) {
        self.send_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send_error(&mut self) -> &mut CommandSendError {
        if self.send_error.is_none() {
            self.send_error.set_default();
        }
        self.send_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_send_error(&mut self) -> CommandSendError {
        self.send_error.take().unwrap_or_else(|| CommandSendError::new())
    }

    pub fn get_send_error(&self) -> &CommandSendError {
        self.send_error.as_ref().unwrap_or_else(|| CommandSendError::default_instance())
    }

    // optional .pulsar.proto.CommandMessage message = 9;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CommandMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CommandMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> CommandMessage {
        self.message.take().unwrap_or_else(|| CommandMessage::new())
    }

    pub fn get_message(&self) -> &CommandMessage {
        self.message.as_ref().unwrap_or_else(|| CommandMessage::default_instance())
    }

    // optional .pulsar.proto.CommandAck ack = 10;

    pub fn clear_ack(&mut self) {
        self.ack.clear();
    }

    pub fn has_ack(&self) -> bool {
        self.ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack(&mut self, v: CommandAck) {
        self.ack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ack(&mut self) -> &mut CommandAck {
        if self.ack.is_none() {
            self.ack.set_default();
        }
        self.ack.as_mut().unwrap()
    }

    // Take field
    pub fn take_ack(&mut self) -> CommandAck {
        self.ack.take().unwrap_or_else(|| CommandAck::new())
    }

    pub fn get_ack(&self) -> &CommandAck {
        self.ack.as_ref().unwrap_or_else(|| CommandAck::default_instance())
    }

    // optional .pulsar.proto.CommandFlow flow = 11;

    pub fn clear_flow(&mut self) {
        self.flow.clear();
    }

    pub fn has_flow(&self) -> bool {
        self.flow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flow(&mut self, v: CommandFlow) {
        self.flow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flow(&mut self) -> &mut CommandFlow {
        if self.flow.is_none() {
            self.flow.set_default();
        }
        self.flow.as_mut().unwrap()
    }

    // Take field
    pub fn take_flow(&mut self) -> CommandFlow {
        self.flow.take().unwrap_or_else(|| CommandFlow::new())
    }

    pub fn get_flow(&self) -> &CommandFlow {
        self.flow.as_ref().unwrap_or_else(|| CommandFlow::default_instance())
    }

    // optional .pulsar.proto.CommandUnsubscribe unsubscribe = 12;

    pub fn clear_unsubscribe(&mut self) {
        self.unsubscribe.clear();
    }

    pub fn has_unsubscribe(&self) -> bool {
        self.unsubscribe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe(&mut self, v: CommandUnsubscribe) {
        self.unsubscribe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unsubscribe(&mut self) -> &mut CommandUnsubscribe {
        if self.unsubscribe.is_none() {
            self.unsubscribe.set_default();
        }
        self.unsubscribe.as_mut().unwrap()
    }

    // Take field
    pub fn take_unsubscribe(&mut self) -> CommandUnsubscribe {
        self.unsubscribe.take().unwrap_or_else(|| CommandUnsubscribe::new())
    }

    pub fn get_unsubscribe(&self) -> &CommandUnsubscribe {
        self.unsubscribe.as_ref().unwrap_or_else(|| CommandUnsubscribe::default_instance())
    }

    // optional .pulsar.proto.CommandSuccess success = 13;

    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: CommandSuccess) {
        self.success = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_success(&mut self) -> &mut CommandSuccess {
        if self.success.is_none() {
            self.success.set_default();
        }
        self.success.as_mut().unwrap()
    }

    // Take field
    pub fn take_success(&mut self) -> CommandSuccess {
        self.success.take().unwrap_or_else(|| CommandSuccess::new())
    }

    pub fn get_success(&self) -> &CommandSuccess {
        self.success.as_ref().unwrap_or_else(|| CommandSuccess::default_instance())
    }

    // optional .pulsar.proto.CommandError error = 14;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CommandError) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut CommandError {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> CommandError {
        self.error.take().unwrap_or_else(|| CommandError::new())
    }

    pub fn get_error(&self) -> &CommandError {
        self.error.as_ref().unwrap_or_else(|| CommandError::default_instance())
    }

    // optional .pulsar.proto.CommandCloseProducer close_producer = 15;

    pub fn clear_close_producer(&mut self) {
        self.close_producer.clear();
    }

    pub fn has_close_producer(&self) -> bool {
        self.close_producer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_producer(&mut self, v: CommandCloseProducer) {
        self.close_producer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_producer(&mut self) -> &mut CommandCloseProducer {
        if self.close_producer.is_none() {
            self.close_producer.set_default();
        }
        self.close_producer.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_producer(&mut self) -> CommandCloseProducer {
        self.close_producer.take().unwrap_or_else(|| CommandCloseProducer::new())
    }

    pub fn get_close_producer(&self) -> &CommandCloseProducer {
        self.close_producer.as_ref().unwrap_or_else(|| CommandCloseProducer::default_instance())
    }

    // optional .pulsar.proto.CommandCloseConsumer close_consumer = 16;

    pub fn clear_close_consumer(&mut self) {
        self.close_consumer.clear();
    }

    pub fn has_close_consumer(&self) -> bool {
        self.close_consumer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_consumer(&mut self, v: CommandCloseConsumer) {
        self.close_consumer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_consumer(&mut self) -> &mut CommandCloseConsumer {
        if self.close_consumer.is_none() {
            self.close_consumer.set_default();
        }
        self.close_consumer.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_consumer(&mut self) -> CommandCloseConsumer {
        self.close_consumer.take().unwrap_or_else(|| CommandCloseConsumer::new())
    }

    pub fn get_close_consumer(&self) -> &CommandCloseConsumer {
        self.close_consumer.as_ref().unwrap_or_else(|| CommandCloseConsumer::default_instance())
    }

    // optional .pulsar.proto.CommandProducerSuccess producer_success = 17;

    pub fn clear_producer_success(&mut self) {
        self.producer_success.clear();
    }

    pub fn has_producer_success(&self) -> bool {
        self.producer_success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_success(&mut self, v: CommandProducerSuccess) {
        self.producer_success = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_success(&mut self) -> &mut CommandProducerSuccess {
        if self.producer_success.is_none() {
            self.producer_success.set_default();
        }
        self.producer_success.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_success(&mut self) -> CommandProducerSuccess {
        self.producer_success.take().unwrap_or_else(|| CommandProducerSuccess::new())
    }

    pub fn get_producer_success(&self) -> &CommandProducerSuccess {
        self.producer_success.as_ref().unwrap_or_else(|| CommandProducerSuccess::default_instance())
    }

    // optional .pulsar.proto.CommandPing ping = 18;

    pub fn clear_ping(&mut self) {
        self.ping.clear();
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: CommandPing) {
        self.ping = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ping(&mut self) -> &mut CommandPing {
        if self.ping.is_none() {
            self.ping.set_default();
        }
        self.ping.as_mut().unwrap()
    }

    // Take field
    pub fn take_ping(&mut self) -> CommandPing {
        self.ping.take().unwrap_or_else(|| CommandPing::new())
    }

    pub fn get_ping(&self) -> &CommandPing {
        self.ping.as_ref().unwrap_or_else(|| CommandPing::default_instance())
    }

    // optional .pulsar.proto.CommandPong pong = 19;

    pub fn clear_pong(&mut self) {
        self.pong.clear();
    }

    pub fn has_pong(&self) -> bool {
        self.pong.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: CommandPong) {
        self.pong = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pong(&mut self) -> &mut CommandPong {
        if self.pong.is_none() {
            self.pong.set_default();
        }
        self.pong.as_mut().unwrap()
    }

    // Take field
    pub fn take_pong(&mut self) -> CommandPong {
        self.pong.take().unwrap_or_else(|| CommandPong::new())
    }

    pub fn get_pong(&self) -> &CommandPong {
        self.pong.as_ref().unwrap_or_else(|| CommandPong::default_instance())
    }

    // optional .pulsar.proto.CommandRedeliverUnacknowledgedMessages redeliverUnacknowledgedMessages = 20;

    pub fn clear_redeliverUnacknowledgedMessages(&mut self) {
        self.redeliverUnacknowledgedMessages.clear();
    }

    pub fn has_redeliverUnacknowledgedMessages(&self) -> bool {
        self.redeliverUnacknowledgedMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeliverUnacknowledgedMessages(&mut self, v: CommandRedeliverUnacknowledgedMessages) {
        self.redeliverUnacknowledgedMessages = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_redeliverUnacknowledgedMessages(&mut self) -> &mut CommandRedeliverUnacknowledgedMessages {
        if self.redeliverUnacknowledgedMessages.is_none() {
            self.redeliverUnacknowledgedMessages.set_default();
        }
        self.redeliverUnacknowledgedMessages.as_mut().unwrap()
    }

    // Take field
    pub fn take_redeliverUnacknowledgedMessages(&mut self) -> CommandRedeliverUnacknowledgedMessages {
        self.redeliverUnacknowledgedMessages.take().unwrap_or_else(|| CommandRedeliverUnacknowledgedMessages::new())
    }

    pub fn get_redeliverUnacknowledgedMessages(&self) -> &CommandRedeliverUnacknowledgedMessages {
        self.redeliverUnacknowledgedMessages.as_ref().unwrap_or_else(|| CommandRedeliverUnacknowledgedMessages::default_instance())
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadata partitionMetadata = 21;

    pub fn clear_partitionMetadata(&mut self) {
        self.partitionMetadata.clear();
    }

    pub fn has_partitionMetadata(&self) -> bool {
        self.partitionMetadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitionMetadata(&mut self, v: CommandPartitionedTopicMetadata) {
        self.partitionMetadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partitionMetadata(&mut self) -> &mut CommandPartitionedTopicMetadata {
        if self.partitionMetadata.is_none() {
            self.partitionMetadata.set_default();
        }
        self.partitionMetadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_partitionMetadata(&mut self) -> CommandPartitionedTopicMetadata {
        self.partitionMetadata.take().unwrap_or_else(|| CommandPartitionedTopicMetadata::new())
    }

    pub fn get_partitionMetadata(&self) -> &CommandPartitionedTopicMetadata {
        self.partitionMetadata.as_ref().unwrap_or_else(|| CommandPartitionedTopicMetadata::default_instance())
    }

    // optional .pulsar.proto.CommandPartitionedTopicMetadataResponse partitionMetadataResponse = 22;

    pub fn clear_partitionMetadataResponse(&mut self) {
        self.partitionMetadataResponse.clear();
    }

    pub fn has_partitionMetadataResponse(&self) -> bool {
        self.partitionMetadataResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partitionMetadataResponse(&mut self, v: CommandPartitionedTopicMetadataResponse) {
        self.partitionMetadataResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_partitionMetadataResponse(&mut self) -> &mut CommandPartitionedTopicMetadataResponse {
        if self.partitionMetadataResponse.is_none() {
            self.partitionMetadataResponse.set_default();
        }
        self.partitionMetadataResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_partitionMetadataResponse(&mut self) -> CommandPartitionedTopicMetadataResponse {
        self.partitionMetadataResponse.take().unwrap_or_else(|| CommandPartitionedTopicMetadataResponse::new())
    }

    pub fn get_partitionMetadataResponse(&self) -> &CommandPartitionedTopicMetadataResponse {
        self.partitionMetadataResponse.as_ref().unwrap_or_else(|| CommandPartitionedTopicMetadataResponse::default_instance())
    }

    // optional .pulsar.proto.CommandLookupTopic lookupTopic = 23;

    pub fn clear_lookupTopic(&mut self) {
        self.lookupTopic.clear();
    }

    pub fn has_lookupTopic(&self) -> bool {
        self.lookupTopic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookupTopic(&mut self, v: CommandLookupTopic) {
        self.lookupTopic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lookupTopic(&mut self) -> &mut CommandLookupTopic {
        if self.lookupTopic.is_none() {
            self.lookupTopic.set_default();
        }
        self.lookupTopic.as_mut().unwrap()
    }

    // Take field
    pub fn take_lookupTopic(&mut self) -> CommandLookupTopic {
        self.lookupTopic.take().unwrap_or_else(|| CommandLookupTopic::new())
    }

    pub fn get_lookupTopic(&self) -> &CommandLookupTopic {
        self.lookupTopic.as_ref().unwrap_or_else(|| CommandLookupTopic::default_instance())
    }

    // optional .pulsar.proto.CommandLookupTopicResponse lookupTopicResponse = 24;

    pub fn clear_lookupTopicResponse(&mut self) {
        self.lookupTopicResponse.clear();
    }

    pub fn has_lookupTopicResponse(&self) -> bool {
        self.lookupTopicResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookupTopicResponse(&mut self, v: CommandLookupTopicResponse) {
        self.lookupTopicResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lookupTopicResponse(&mut self) -> &mut CommandLookupTopicResponse {
        if self.lookupTopicResponse.is_none() {
            self.lookupTopicResponse.set_default();
        }
        self.lookupTopicResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_lookupTopicResponse(&mut self) -> CommandLookupTopicResponse {
        self.lookupTopicResponse.take().unwrap_or_else(|| CommandLookupTopicResponse::new())
    }

    pub fn get_lookupTopicResponse(&self) -> &CommandLookupTopicResponse {
        self.lookupTopicResponse.as_ref().unwrap_or_else(|| CommandLookupTopicResponse::default_instance())
    }

    // optional .pulsar.proto.CommandConsumerStats consumerStats = 25;

    pub fn clear_consumerStats(&mut self) {
        self.consumerStats.clear();
    }

    pub fn has_consumerStats(&self) -> bool {
        self.consumerStats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerStats(&mut self, v: CommandConsumerStats) {
        self.consumerStats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerStats(&mut self) -> &mut CommandConsumerStats {
        if self.consumerStats.is_none() {
            self.consumerStats.set_default();
        }
        self.consumerStats.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerStats(&mut self) -> CommandConsumerStats {
        self.consumerStats.take().unwrap_or_else(|| CommandConsumerStats::new())
    }

    pub fn get_consumerStats(&self) -> &CommandConsumerStats {
        self.consumerStats.as_ref().unwrap_or_else(|| CommandConsumerStats::default_instance())
    }

    // optional .pulsar.proto.CommandConsumerStatsResponse consumerStatsResponse = 26;

    pub fn clear_consumerStatsResponse(&mut self) {
        self.consumerStatsResponse.clear();
    }

    pub fn has_consumerStatsResponse(&self) -> bool {
        self.consumerStatsResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumerStatsResponse(&mut self, v: CommandConsumerStatsResponse) {
        self.consumerStatsResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumerStatsResponse(&mut self) -> &mut CommandConsumerStatsResponse {
        if self.consumerStatsResponse.is_none() {
            self.consumerStatsResponse.set_default();
        }
        self.consumerStatsResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumerStatsResponse(&mut self) -> CommandConsumerStatsResponse {
        self.consumerStatsResponse.take().unwrap_or_else(|| CommandConsumerStatsResponse::new())
    }

    pub fn get_consumerStatsResponse(&self) -> &CommandConsumerStatsResponse {
        self.consumerStatsResponse.as_ref().unwrap_or_else(|| CommandConsumerStatsResponse::default_instance())
    }

    // optional .pulsar.proto.CommandReachedEndOfTopic reachedEndOfTopic = 27;

    pub fn clear_reachedEndOfTopic(&mut self) {
        self.reachedEndOfTopic.clear();
    }

    pub fn has_reachedEndOfTopic(&self) -> bool {
        self.reachedEndOfTopic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reachedEndOfTopic(&mut self, v: CommandReachedEndOfTopic) {
        self.reachedEndOfTopic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reachedEndOfTopic(&mut self) -> &mut CommandReachedEndOfTopic {
        if self.reachedEndOfTopic.is_none() {
            self.reachedEndOfTopic.set_default();
        }
        self.reachedEndOfTopic.as_mut().unwrap()
    }

    // Take field
    pub fn take_reachedEndOfTopic(&mut self) -> CommandReachedEndOfTopic {
        self.reachedEndOfTopic.take().unwrap_or_else(|| CommandReachedEndOfTopic::new())
    }

    pub fn get_reachedEndOfTopic(&self) -> &CommandReachedEndOfTopic {
        self.reachedEndOfTopic.as_ref().unwrap_or_else(|| CommandReachedEndOfTopic::default_instance())
    }

    // optional .pulsar.proto.CommandSeek seek = 28;

    pub fn clear_seek(&mut self) {
        self.seek.clear();
    }

    pub fn has_seek(&self) -> bool {
        self.seek.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seek(&mut self, v: CommandSeek) {
        self.seek = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seek(&mut self) -> &mut CommandSeek {
        if self.seek.is_none() {
            self.seek.set_default();
        }
        self.seek.as_mut().unwrap()
    }

    // Take field
    pub fn take_seek(&mut self) -> CommandSeek {
        self.seek.take().unwrap_or_else(|| CommandSeek::new())
    }

    pub fn get_seek(&self) -> &CommandSeek {
        self.seek.as_ref().unwrap_or_else(|| CommandSeek::default_instance())
    }

    // optional .pulsar.proto.CommandGetLastMessageId getLastMessageId = 29;

    pub fn clear_getLastMessageId(&mut self) {
        self.getLastMessageId.clear();
    }

    pub fn has_getLastMessageId(&self) -> bool {
        self.getLastMessageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLastMessageId(&mut self, v: CommandGetLastMessageId) {
        self.getLastMessageId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLastMessageId(&mut self) -> &mut CommandGetLastMessageId {
        if self.getLastMessageId.is_none() {
            self.getLastMessageId.set_default();
        }
        self.getLastMessageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLastMessageId(&mut self) -> CommandGetLastMessageId {
        self.getLastMessageId.take().unwrap_or_else(|| CommandGetLastMessageId::new())
    }

    pub fn get_getLastMessageId(&self) -> &CommandGetLastMessageId {
        self.getLastMessageId.as_ref().unwrap_or_else(|| CommandGetLastMessageId::default_instance())
    }

    // optional .pulsar.proto.CommandGetLastMessageIdResponse getLastMessageIdResponse = 30;

    pub fn clear_getLastMessageIdResponse(&mut self) {
        self.getLastMessageIdResponse.clear();
    }

    pub fn has_getLastMessageIdResponse(&self) -> bool {
        self.getLastMessageIdResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLastMessageIdResponse(&mut self, v: CommandGetLastMessageIdResponse) {
        self.getLastMessageIdResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLastMessageIdResponse(&mut self) -> &mut CommandGetLastMessageIdResponse {
        if self.getLastMessageIdResponse.is_none() {
            self.getLastMessageIdResponse.set_default();
        }
        self.getLastMessageIdResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLastMessageIdResponse(&mut self) -> CommandGetLastMessageIdResponse {
        self.getLastMessageIdResponse.take().unwrap_or_else(|| CommandGetLastMessageIdResponse::new())
    }

    pub fn get_getLastMessageIdResponse(&self) -> &CommandGetLastMessageIdResponse {
        self.getLastMessageIdResponse.as_ref().unwrap_or_else(|| CommandGetLastMessageIdResponse::default_instance())
    }

    // optional .pulsar.proto.CommandActiveConsumerChange active_consumer_change = 31;

    pub fn clear_active_consumer_change(&mut self) {
        self.active_consumer_change.clear();
    }

    pub fn has_active_consumer_change(&self) -> bool {
        self.active_consumer_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_consumer_change(&mut self, v: CommandActiveConsumerChange) {
        self.active_consumer_change = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active_consumer_change(&mut self) -> &mut CommandActiveConsumerChange {
        if self.active_consumer_change.is_none() {
            self.active_consumer_change.set_default();
        }
        self.active_consumer_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_active_consumer_change(&mut self) -> CommandActiveConsumerChange {
        self.active_consumer_change.take().unwrap_or_else(|| CommandActiveConsumerChange::new())
    }

    pub fn get_active_consumer_change(&self) -> &CommandActiveConsumerChange {
        self.active_consumer_change.as_ref().unwrap_or_else(|| CommandActiveConsumerChange::default_instance())
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespace getTopicsOfNamespace = 32;

    pub fn clear_getTopicsOfNamespace(&mut self) {
        self.getTopicsOfNamespace.clear();
    }

    pub fn has_getTopicsOfNamespace(&self) -> bool {
        self.getTopicsOfNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getTopicsOfNamespace(&mut self, v: CommandGetTopicsOfNamespace) {
        self.getTopicsOfNamespace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getTopicsOfNamespace(&mut self) -> &mut CommandGetTopicsOfNamespace {
        if self.getTopicsOfNamespace.is_none() {
            self.getTopicsOfNamespace.set_default();
        }
        self.getTopicsOfNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_getTopicsOfNamespace(&mut self) -> CommandGetTopicsOfNamespace {
        self.getTopicsOfNamespace.take().unwrap_or_else(|| CommandGetTopicsOfNamespace::new())
    }

    pub fn get_getTopicsOfNamespace(&self) -> &CommandGetTopicsOfNamespace {
        self.getTopicsOfNamespace.as_ref().unwrap_or_else(|| CommandGetTopicsOfNamespace::default_instance())
    }

    // optional .pulsar.proto.CommandGetTopicsOfNamespaceResponse getTopicsOfNamespaceResponse = 33;

    pub fn clear_getTopicsOfNamespaceResponse(&mut self) {
        self.getTopicsOfNamespaceResponse.clear();
    }

    pub fn has_getTopicsOfNamespaceResponse(&self) -> bool {
        self.getTopicsOfNamespaceResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getTopicsOfNamespaceResponse(&mut self, v: CommandGetTopicsOfNamespaceResponse) {
        self.getTopicsOfNamespaceResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getTopicsOfNamespaceResponse(&mut self) -> &mut CommandGetTopicsOfNamespaceResponse {
        if self.getTopicsOfNamespaceResponse.is_none() {
            self.getTopicsOfNamespaceResponse.set_default();
        }
        self.getTopicsOfNamespaceResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getTopicsOfNamespaceResponse(&mut self) -> CommandGetTopicsOfNamespaceResponse {
        self.getTopicsOfNamespaceResponse.take().unwrap_or_else(|| CommandGetTopicsOfNamespaceResponse::new())
    }

    pub fn get_getTopicsOfNamespaceResponse(&self) -> &CommandGetTopicsOfNamespaceResponse {
        self.getTopicsOfNamespaceResponse.as_ref().unwrap_or_else(|| CommandGetTopicsOfNamespaceResponse::default_instance())
    }

    // optional .pulsar.proto.CommandGetSchema getSchema = 34;

    pub fn clear_getSchema(&mut self) {
        self.getSchema.clear();
    }

    pub fn has_getSchema(&self) -> bool {
        self.getSchema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSchema(&mut self, v: CommandGetSchema) {
        self.getSchema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSchema(&mut self) -> &mut CommandGetSchema {
        if self.getSchema.is_none() {
            self.getSchema.set_default();
        }
        self.getSchema.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSchema(&mut self) -> CommandGetSchema {
        self.getSchema.take().unwrap_or_else(|| CommandGetSchema::new())
    }

    pub fn get_getSchema(&self) -> &CommandGetSchema {
        self.getSchema.as_ref().unwrap_or_else(|| CommandGetSchema::default_instance())
    }

    // optional .pulsar.proto.CommandGetSchemaResponse getSchemaResponse = 35;

    pub fn clear_getSchemaResponse(&mut self) {
        self.getSchemaResponse.clear();
    }

    pub fn has_getSchemaResponse(&self) -> bool {
        self.getSchemaResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getSchemaResponse(&mut self, v: CommandGetSchemaResponse) {
        self.getSchemaResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getSchemaResponse(&mut self) -> &mut CommandGetSchemaResponse {
        if self.getSchemaResponse.is_none() {
            self.getSchemaResponse.set_default();
        }
        self.getSchemaResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_getSchemaResponse(&mut self) -> CommandGetSchemaResponse {
        self.getSchemaResponse.take().unwrap_or_else(|| CommandGetSchemaResponse::new())
    }

    pub fn get_getSchemaResponse(&self) -> &CommandGetSchemaResponse {
        self.getSchemaResponse.as_ref().unwrap_or_else(|| CommandGetSchemaResponse::default_instance())
    }
}

impl ::protobuf::Message for BaseCommand {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.connect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subscribe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.producer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send_receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsubscribe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.close_producer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.close_consumer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.producer_success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ping {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pong {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.redeliverUnacknowledgedMessages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partitionMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partitionMetadataResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lookupTopic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lookupTopicResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumerStats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumerStatsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reachedEndOfTopic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seek {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLastMessageId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLastMessageIdResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_consumer_change {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getTopicsOfNamespace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getTopicsOfNamespaceResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSchema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getSchemaResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connect)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connected)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subscribe)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.producer)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send_receipt)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send_error)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ack)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flow)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unsubscribe)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.success)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.close_producer)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.close_consumer)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.producer_success)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ping)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pong)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.redeliverUnacknowledgedMessages)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partitionMetadata)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.partitionMetadataResponse)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lookupTopic)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lookupTopicResponse)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumerStats)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumerStatsResponse)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reachedEndOfTopic)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seek)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLastMessageId)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLastMessageIdResponse)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active_consumer_change)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getTopicsOfNamespace)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getTopicsOfNamespaceResponse)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSchema)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getSchemaResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.connect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.connected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subscribe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.producer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send_receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.send_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unsubscribe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.success.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.close_producer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.close_consumer.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.producer_success.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ping.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pong.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.redeliverUnacknowledgedMessages.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.partitionMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.partitionMetadataResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lookupTopic.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lookupTopicResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumerStats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumerStatsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reachedEndOfTopic.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.seek.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLastMessageId.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLastMessageIdResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.active_consumer_change.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getTopicsOfNamespace.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getTopicsOfNamespaceResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSchema.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getSchemaResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.connect.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.connected.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subscribe.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.producer.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send_receipt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.send_error.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ack.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flow.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unsubscribe.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.success.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.close_producer.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.close_consumer.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.producer_success.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ping.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pong.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.redeliverUnacknowledgedMessages.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.partitionMetadata.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.partitionMetadataResponse.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lookupTopic.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lookupTopicResponse.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumerStats.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumerStatsResponse.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reachedEndOfTopic.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.seek.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLastMessageId.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLastMessageIdResponse.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.active_consumer_change.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getTopicsOfNamespace.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getTopicsOfNamespaceResponse.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSchema.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getSchemaResponse.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseCommand {
        BaseCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BaseCommand_Type>>(
                    "type",
                    |m: &BaseCommand| { &m.field_type },
                    |m: &mut BaseCommand| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandConnect>>(
                    "connect",
                    |m: &BaseCommand| { &m.connect },
                    |m: &mut BaseCommand| { &mut m.connect },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandConnected>>(
                    "connected",
                    |m: &BaseCommand| { &m.connected },
                    |m: &mut BaseCommand| { &mut m.connected },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSubscribe>>(
                    "subscribe",
                    |m: &BaseCommand| { &m.subscribe },
                    |m: &mut BaseCommand| { &mut m.subscribe },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandProducer>>(
                    "producer",
                    |m: &BaseCommand| { &m.producer },
                    |m: &mut BaseCommand| { &mut m.producer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSend>>(
                    "send",
                    |m: &BaseCommand| { &m.send },
                    |m: &mut BaseCommand| { &mut m.send },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSendReceipt>>(
                    "send_receipt",
                    |m: &BaseCommand| { &m.send_receipt },
                    |m: &mut BaseCommand| { &mut m.send_receipt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSendError>>(
                    "send_error",
                    |m: &BaseCommand| { &m.send_error },
                    |m: &mut BaseCommand| { &mut m.send_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandMessage>>(
                    "message",
                    |m: &BaseCommand| { &m.message },
                    |m: &mut BaseCommand| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandAck>>(
                    "ack",
                    |m: &BaseCommand| { &m.ack },
                    |m: &mut BaseCommand| { &mut m.ack },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandFlow>>(
                    "flow",
                    |m: &BaseCommand| { &m.flow },
                    |m: &mut BaseCommand| { &mut m.flow },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandUnsubscribe>>(
                    "unsubscribe",
                    |m: &BaseCommand| { &m.unsubscribe },
                    |m: &mut BaseCommand| { &mut m.unsubscribe },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSuccess>>(
                    "success",
                    |m: &BaseCommand| { &m.success },
                    |m: &mut BaseCommand| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandError>>(
                    "error",
                    |m: &BaseCommand| { &m.error },
                    |m: &mut BaseCommand| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandCloseProducer>>(
                    "close_producer",
                    |m: &BaseCommand| { &m.close_producer },
                    |m: &mut BaseCommand| { &mut m.close_producer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandCloseConsumer>>(
                    "close_consumer",
                    |m: &BaseCommand| { &m.close_consumer },
                    |m: &mut BaseCommand| { &mut m.close_consumer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandProducerSuccess>>(
                    "producer_success",
                    |m: &BaseCommand| { &m.producer_success },
                    |m: &mut BaseCommand| { &mut m.producer_success },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandPing>>(
                    "ping",
                    |m: &BaseCommand| { &m.ping },
                    |m: &mut BaseCommand| { &mut m.ping },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandPong>>(
                    "pong",
                    |m: &BaseCommand| { &m.pong },
                    |m: &mut BaseCommand| { &mut m.pong },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandRedeliverUnacknowledgedMessages>>(
                    "redeliverUnacknowledgedMessages",
                    |m: &BaseCommand| { &m.redeliverUnacknowledgedMessages },
                    |m: &mut BaseCommand| { &mut m.redeliverUnacknowledgedMessages },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandPartitionedTopicMetadata>>(
                    "partitionMetadata",
                    |m: &BaseCommand| { &m.partitionMetadata },
                    |m: &mut BaseCommand| { &mut m.partitionMetadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandPartitionedTopicMetadataResponse>>(
                    "partitionMetadataResponse",
                    |m: &BaseCommand| { &m.partitionMetadataResponse },
                    |m: &mut BaseCommand| { &mut m.partitionMetadataResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandLookupTopic>>(
                    "lookupTopic",
                    |m: &BaseCommand| { &m.lookupTopic },
                    |m: &mut BaseCommand| { &mut m.lookupTopic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandLookupTopicResponse>>(
                    "lookupTopicResponse",
                    |m: &BaseCommand| { &m.lookupTopicResponse },
                    |m: &mut BaseCommand| { &mut m.lookupTopicResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandConsumerStats>>(
                    "consumerStats",
                    |m: &BaseCommand| { &m.consumerStats },
                    |m: &mut BaseCommand| { &mut m.consumerStats },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandConsumerStatsResponse>>(
                    "consumerStatsResponse",
                    |m: &BaseCommand| { &m.consumerStatsResponse },
                    |m: &mut BaseCommand| { &mut m.consumerStatsResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandReachedEndOfTopic>>(
                    "reachedEndOfTopic",
                    |m: &BaseCommand| { &m.reachedEndOfTopic },
                    |m: &mut BaseCommand| { &mut m.reachedEndOfTopic },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandSeek>>(
                    "seek",
                    |m: &BaseCommand| { &m.seek },
                    |m: &mut BaseCommand| { &mut m.seek },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetLastMessageId>>(
                    "getLastMessageId",
                    |m: &BaseCommand| { &m.getLastMessageId },
                    |m: &mut BaseCommand| { &mut m.getLastMessageId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetLastMessageIdResponse>>(
                    "getLastMessageIdResponse",
                    |m: &BaseCommand| { &m.getLastMessageIdResponse },
                    |m: &mut BaseCommand| { &mut m.getLastMessageIdResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandActiveConsumerChange>>(
                    "active_consumer_change",
                    |m: &BaseCommand| { &m.active_consumer_change },
                    |m: &mut BaseCommand| { &mut m.active_consumer_change },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetTopicsOfNamespace>>(
                    "getTopicsOfNamespace",
                    |m: &BaseCommand| { &m.getTopicsOfNamespace },
                    |m: &mut BaseCommand| { &mut m.getTopicsOfNamespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetTopicsOfNamespaceResponse>>(
                    "getTopicsOfNamespaceResponse",
                    |m: &BaseCommand| { &m.getTopicsOfNamespaceResponse },
                    |m: &mut BaseCommand| { &mut m.getTopicsOfNamespaceResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetSchema>>(
                    "getSchema",
                    |m: &BaseCommand| { &m.getSchema },
                    |m: &mut BaseCommand| { &mut m.getSchema },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommandGetSchemaResponse>>(
                    "getSchemaResponse",
                    |m: &BaseCommand| { &m.getSchemaResponse },
                    |m: &mut BaseCommand| { &mut m.getSchemaResponse },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BaseCommand>(
                    "BaseCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BaseCommand {
        static mut instance: ::protobuf::lazy::Lazy<BaseCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseCommand,
        };
        unsafe {
            instance.get(BaseCommand::new)
        }
    }
}

impl ::protobuf::Clear for BaseCommand {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_connect();
        self.clear_connected();
        self.clear_subscribe();
        self.clear_producer();
        self.clear_send();
        self.clear_send_receipt();
        self.clear_send_error();
        self.clear_message();
        self.clear_ack();
        self.clear_flow();
        self.clear_unsubscribe();
        self.clear_success();
        self.clear_error();
        self.clear_close_producer();
        self.clear_close_consumer();
        self.clear_producer_success();
        self.clear_ping();
        self.clear_pong();
        self.clear_redeliverUnacknowledgedMessages();
        self.clear_partitionMetadata();
        self.clear_partitionMetadataResponse();
        self.clear_lookupTopic();
        self.clear_lookupTopicResponse();
        self.clear_consumerStats();
        self.clear_consumerStatsResponse();
        self.clear_reachedEndOfTopic();
        self.clear_seek();
        self.clear_getLastMessageId();
        self.clear_getLastMessageIdResponse();
        self.clear_active_consumer_change();
        self.clear_getTopicsOfNamespace();
        self.clear_getTopicsOfNamespaceResponse();
        self.clear_getSchema();
        self.clear_getSchemaResponse();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BaseCommand_Type {
    CONNECT = 2,
    CONNECTED = 3,
    SUBSCRIBE = 4,
    PRODUCER = 5,
    SEND = 6,
    SEND_RECEIPT = 7,
    SEND_ERROR = 8,
    MESSAGE = 9,
    ACK = 10,
    FLOW = 11,
    UNSUBSCRIBE = 12,
    SUCCESS = 13,
    ERROR = 14,
    CLOSE_PRODUCER = 15,
    CLOSE_CONSUMER = 16,
    PRODUCER_SUCCESS = 17,
    PING = 18,
    PONG = 19,
    REDELIVER_UNACKNOWLEDGED_MESSAGES = 20,
    PARTITIONED_METADATA = 21,
    PARTITIONED_METADATA_RESPONSE = 22,
    LOOKUP = 23,
    LOOKUP_RESPONSE = 24,
    CONSUMER_STATS = 25,
    CONSUMER_STATS_RESPONSE = 26,
    REACHED_END_OF_TOPIC = 27,
    SEEK = 28,
    GET_LAST_MESSAGE_ID = 29,
    GET_LAST_MESSAGE_ID_RESPONSE = 30,
    ACTIVE_CONSUMER_CHANGE = 31,
    GET_TOPICS_OF_NAMESPACE = 32,
    GET_TOPICS_OF_NAMESPACE_RESPONSE = 33,
    GET_SCHEMA = 34,
    GET_SCHEMA_RESPONSE = 35,
}

impl ::protobuf::ProtobufEnum for BaseCommand_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BaseCommand_Type> {
        match value {
            2 => ::std::option::Option::Some(BaseCommand_Type::CONNECT),
            3 => ::std::option::Option::Some(BaseCommand_Type::CONNECTED),
            4 => ::std::option::Option::Some(BaseCommand_Type::SUBSCRIBE),
            5 => ::std::option::Option::Some(BaseCommand_Type::PRODUCER),
            6 => ::std::option::Option::Some(BaseCommand_Type::SEND),
            7 => ::std::option::Option::Some(BaseCommand_Type::SEND_RECEIPT),
            8 => ::std::option::Option::Some(BaseCommand_Type::SEND_ERROR),
            9 => ::std::option::Option::Some(BaseCommand_Type::MESSAGE),
            10 => ::std::option::Option::Some(BaseCommand_Type::ACK),
            11 => ::std::option::Option::Some(BaseCommand_Type::FLOW),
            12 => ::std::option::Option::Some(BaseCommand_Type::UNSUBSCRIBE),
            13 => ::std::option::Option::Some(BaseCommand_Type::SUCCESS),
            14 => ::std::option::Option::Some(BaseCommand_Type::ERROR),
            15 => ::std::option::Option::Some(BaseCommand_Type::CLOSE_PRODUCER),
            16 => ::std::option::Option::Some(BaseCommand_Type::CLOSE_CONSUMER),
            17 => ::std::option::Option::Some(BaseCommand_Type::PRODUCER_SUCCESS),
            18 => ::std::option::Option::Some(BaseCommand_Type::PING),
            19 => ::std::option::Option::Some(BaseCommand_Type::PONG),
            20 => ::std::option::Option::Some(BaseCommand_Type::REDELIVER_UNACKNOWLEDGED_MESSAGES),
            21 => ::std::option::Option::Some(BaseCommand_Type::PARTITIONED_METADATA),
            22 => ::std::option::Option::Some(BaseCommand_Type::PARTITIONED_METADATA_RESPONSE),
            23 => ::std::option::Option::Some(BaseCommand_Type::LOOKUP),
            24 => ::std::option::Option::Some(BaseCommand_Type::LOOKUP_RESPONSE),
            25 => ::std::option::Option::Some(BaseCommand_Type::CONSUMER_STATS),
            26 => ::std::option::Option::Some(BaseCommand_Type::CONSUMER_STATS_RESPONSE),
            27 => ::std::option::Option::Some(BaseCommand_Type::REACHED_END_OF_TOPIC),
            28 => ::std::option::Option::Some(BaseCommand_Type::SEEK),
            29 => ::std::option::Option::Some(BaseCommand_Type::GET_LAST_MESSAGE_ID),
            30 => ::std::option::Option::Some(BaseCommand_Type::GET_LAST_MESSAGE_ID_RESPONSE),
            31 => ::std::option::Option::Some(BaseCommand_Type::ACTIVE_CONSUMER_CHANGE),
            32 => ::std::option::Option::Some(BaseCommand_Type::GET_TOPICS_OF_NAMESPACE),
            33 => ::std::option::Option::Some(BaseCommand_Type::GET_TOPICS_OF_NAMESPACE_RESPONSE),
            34 => ::std::option::Option::Some(BaseCommand_Type::GET_SCHEMA),
            35 => ::std::option::Option::Some(BaseCommand_Type::GET_SCHEMA_RESPONSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BaseCommand_Type] = &[
            BaseCommand_Type::CONNECT,
            BaseCommand_Type::CONNECTED,
            BaseCommand_Type::SUBSCRIBE,
            BaseCommand_Type::PRODUCER,
            BaseCommand_Type::SEND,
            BaseCommand_Type::SEND_RECEIPT,
            BaseCommand_Type::SEND_ERROR,
            BaseCommand_Type::MESSAGE,
            BaseCommand_Type::ACK,
            BaseCommand_Type::FLOW,
            BaseCommand_Type::UNSUBSCRIBE,
            BaseCommand_Type::SUCCESS,
            BaseCommand_Type::ERROR,
            BaseCommand_Type::CLOSE_PRODUCER,
            BaseCommand_Type::CLOSE_CONSUMER,
            BaseCommand_Type::PRODUCER_SUCCESS,
            BaseCommand_Type::PING,
            BaseCommand_Type::PONG,
            BaseCommand_Type::REDELIVER_UNACKNOWLEDGED_MESSAGES,
            BaseCommand_Type::PARTITIONED_METADATA,
            BaseCommand_Type::PARTITIONED_METADATA_RESPONSE,
            BaseCommand_Type::LOOKUP,
            BaseCommand_Type::LOOKUP_RESPONSE,
            BaseCommand_Type::CONSUMER_STATS,
            BaseCommand_Type::CONSUMER_STATS_RESPONSE,
            BaseCommand_Type::REACHED_END_OF_TOPIC,
            BaseCommand_Type::SEEK,
            BaseCommand_Type::GET_LAST_MESSAGE_ID,
            BaseCommand_Type::GET_LAST_MESSAGE_ID_RESPONSE,
            BaseCommand_Type::ACTIVE_CONSUMER_CHANGE,
            BaseCommand_Type::GET_TOPICS_OF_NAMESPACE,
            BaseCommand_Type::GET_TOPICS_OF_NAMESPACE_RESPONSE,
            BaseCommand_Type::GET_SCHEMA,
            BaseCommand_Type::GET_SCHEMA_RESPONSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BaseCommand_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BaseCommand_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BaseCommand_Type {
    fn default() -> Self {
        BaseCommand_Type::CONNECT
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseCommand_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompressionType {
    NONE = 0,
    LZ4 = 1,
    ZLIB = 2,
    ZSTD = 3,
}

impl ::protobuf::ProtobufEnum for CompressionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionType> {
        match value {
            0 => ::std::option::Option::Some(CompressionType::NONE),
            1 => ::std::option::Option::Some(CompressionType::LZ4),
            2 => ::std::option::Option::Some(CompressionType::ZLIB),
            3 => ::std::option::Option::Some(CompressionType::ZSTD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompressionType] = &[
            CompressionType::NONE,
            CompressionType::LZ4,
            CompressionType::ZLIB,
            CompressionType::ZSTD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompressionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompressionType {
}

impl ::std::default::Default for CompressionType {
    fn default() -> Self {
        CompressionType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CompressionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServerError {
    UnknownError = 0,
    MetadataError = 1,
    PersistenceError = 2,
    AuthenticationError = 3,
    AuthorizationError = 4,
    ConsumerBusy = 5,
    ServiceNotReady = 6,
    ProducerBlockedQuotaExceededError = 7,
    ProducerBlockedQuotaExceededException = 8,
    ChecksumError = 9,
    UnsupportedVersionError = 10,
    TopicNotFound = 11,
    SubscriptionNotFound = 12,
    ConsumerNotFound = 13,
    TooManyRequests = 14,
    TopicTerminatedError = 15,
    ProducerBusy = 16,
    InvalidTopicName = 17,
    IncompatibleSchema = 18,
}

impl ::protobuf::ProtobufEnum for ServerError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerError> {
        match value {
            0 => ::std::option::Option::Some(ServerError::UnknownError),
            1 => ::std::option::Option::Some(ServerError::MetadataError),
            2 => ::std::option::Option::Some(ServerError::PersistenceError),
            3 => ::std::option::Option::Some(ServerError::AuthenticationError),
            4 => ::std::option::Option::Some(ServerError::AuthorizationError),
            5 => ::std::option::Option::Some(ServerError::ConsumerBusy),
            6 => ::std::option::Option::Some(ServerError::ServiceNotReady),
            7 => ::std::option::Option::Some(ServerError::ProducerBlockedQuotaExceededError),
            8 => ::std::option::Option::Some(ServerError::ProducerBlockedQuotaExceededException),
            9 => ::std::option::Option::Some(ServerError::ChecksumError),
            10 => ::std::option::Option::Some(ServerError::UnsupportedVersionError),
            11 => ::std::option::Option::Some(ServerError::TopicNotFound),
            12 => ::std::option::Option::Some(ServerError::SubscriptionNotFound),
            13 => ::std::option::Option::Some(ServerError::ConsumerNotFound),
            14 => ::std::option::Option::Some(ServerError::TooManyRequests),
            15 => ::std::option::Option::Some(ServerError::TopicTerminatedError),
            16 => ::std::option::Option::Some(ServerError::ProducerBusy),
            17 => ::std::option::Option::Some(ServerError::InvalidTopicName),
            18 => ::std::option::Option::Some(ServerError::IncompatibleSchema),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServerError] = &[
            ServerError::UnknownError,
            ServerError::MetadataError,
            ServerError::PersistenceError,
            ServerError::AuthenticationError,
            ServerError::AuthorizationError,
            ServerError::ConsumerBusy,
            ServerError::ServiceNotReady,
            ServerError::ProducerBlockedQuotaExceededError,
            ServerError::ProducerBlockedQuotaExceededException,
            ServerError::ChecksumError,
            ServerError::UnsupportedVersionError,
            ServerError::TopicNotFound,
            ServerError::SubscriptionNotFound,
            ServerError::ConsumerNotFound,
            ServerError::TooManyRequests,
            ServerError::TopicTerminatedError,
            ServerError::ProducerBusy,
            ServerError::InvalidTopicName,
            ServerError::IncompatibleSchema,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ServerError", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ServerError {
}

impl ::std::default::Default for ServerError {
    fn default() -> Self {
        ServerError::UnknownError
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerError {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthMethod {
    AuthMethodNone = 0,
    AuthMethodYcaV1 = 1,
    AuthMethodAthens = 2,
}

impl ::protobuf::ProtobufEnum for AuthMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthMethod> {
        match value {
            0 => ::std::option::Option::Some(AuthMethod::AuthMethodNone),
            1 => ::std::option::Option::Some(AuthMethod::AuthMethodYcaV1),
            2 => ::std::option::Option::Some(AuthMethod::AuthMethodAthens),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthMethod] = &[
            AuthMethod::AuthMethodNone,
            AuthMethod::AuthMethodYcaV1,
            AuthMethod::AuthMethodAthens,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AuthMethod", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AuthMethod {
}

impl ::std::default::Default for AuthMethod {
    fn default() -> Self {
        AuthMethod::AuthMethodNone
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtocolVersion {
    v0 = 0,
    v1 = 1,
    v2 = 2,
    v3 = 3,
    v4 = 4,
    v5 = 5,
    v6 = 6,
    v7 = 7,
    v8 = 8,
    v9 = 9,
    v10 = 10,
    v11 = 11,
    v12 = 12,
    v13 = 13,
}

impl ::protobuf::ProtobufEnum for ProtocolVersion {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtocolVersion> {
        match value {
            0 => ::std::option::Option::Some(ProtocolVersion::v0),
            1 => ::std::option::Option::Some(ProtocolVersion::v1),
            2 => ::std::option::Option::Some(ProtocolVersion::v2),
            3 => ::std::option::Option::Some(ProtocolVersion::v3),
            4 => ::std::option::Option::Some(ProtocolVersion::v4),
            5 => ::std::option::Option::Some(ProtocolVersion::v5),
            6 => ::std::option::Option::Some(ProtocolVersion::v6),
            7 => ::std::option::Option::Some(ProtocolVersion::v7),
            8 => ::std::option::Option::Some(ProtocolVersion::v8),
            9 => ::std::option::Option::Some(ProtocolVersion::v9),
            10 => ::std::option::Option::Some(ProtocolVersion::v10),
            11 => ::std::option::Option::Some(ProtocolVersion::v11),
            12 => ::std::option::Option::Some(ProtocolVersion::v12),
            13 => ::std::option::Option::Some(ProtocolVersion::v13),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtocolVersion] = &[
            ProtocolVersion::v0,
            ProtocolVersion::v1,
            ProtocolVersion::v2,
            ProtocolVersion::v3,
            ProtocolVersion::v4,
            ProtocolVersion::v5,
            ProtocolVersion::v6,
            ProtocolVersion::v7,
            ProtocolVersion::v8,
            ProtocolVersion::v9,
            ProtocolVersion::v10,
            ProtocolVersion::v11,
            ProtocolVersion::v12,
            ProtocolVersion::v13,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProtocolVersion", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProtocolVersion {
}

impl ::std::default::Default for ProtocolVersion {
    fn default() -> Self {
        ProtocolVersion::v0
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10pulsar_api.proto\x12\x0cpulsar.proto\"\xca\x02\n\x06Schema\x12\x0e\
    \n\x04name\x18\x01\x20\x02(\tB\0\x12\x15\n\x0bschema_data\x18\x03\x20\
    \x02(\x0cB\0\x12)\n\x04type\x18\x04\x20\x02(\x0e2\x19.pulsar.proto.Schem\
    a.TypeB\0\x12,\n\nproperties\x18\x05\x20\x03(\x0b2\x16.pulsar.proto.KeyV\
    alueB\0\"\xbd\x01\n\x04Type\x12\x08\n\x04None\x10\0\x12\n\n\x06String\
    \x10\x01\x12\x08\n\x04Json\x10\x02\x12\x0c\n\x08Protobuf\x10\x03\x12\x08\
    \n\x04Avro\x10\x04\x12\x08\n\x04Bool\x10\x05\x12\x08\n\x04Int8\x10\x06\
    \x12\t\n\x05Int16\x10\x07\x12\t\n\x05Int32\x10\x08\x12\t\n\x05Int64\x10\
    \t\x12\t\n\x05Float\x10\n\x12\n\n\x06Double\x10\x0b\x12\x08\n\x04Date\
    \x10\x0c\x12\x08\n\x04Time\x10\r\x12\r\n\tTimestamp\x10\x0e\x12\x0c\n\
    \x08KeyValue\x10\x0f\x1a\0:\0\"l\n\rMessageIdData\x12\x12\n\x08ledgerId\
    \x18\x01\x20\x02(\x04B\0\x12\x11\n\x07entryId\x18\x02\x20\x02(\x04B\0\
    \x12\x17\n\tpartition\x18\x03\x20\x01(\x05:\x02-1B\0\x12\x19\n\x0bbatch_\
    index\x18\x04\x20\x01(\x05:\x02-1B\0:\0\",\n\x08KeyValue\x12\r\n\x03key\
    \x18\x01\x20\x02(\tB\0\x12\x0f\n\x05value\x18\x02\x20\x02(\tB\0:\0\"0\n\
    \x0cKeyLongValue\x12\r\n\x03key\x18\x01\x20\x02(\tB\0\x12\x0f\n\x05value\
    \x18\x02\x20\x02(\x04B\0:\0\"^\n\x0eEncryptionKeys\x12\r\n\x03key\x18\
    \x01\x20\x02(\tB\0\x12\x0f\n\x05value\x18\x02\x20\x02(\x0cB\0\x12*\n\x08\
    metadata\x18\x03\x20\x03(\x0b2\x16.pulsar.proto.KeyValueB\0:\0\"\xa4\x04\
    \n\x0fMessageMetadata\x12\x17\n\rproducer_name\x18\x01\x20\x02(\tB\0\x12\
    \x15\n\x0bsequence_id\x18\x02\x20\x02(\x04B\0\x12\x16\n\x0cpublish_time\
    \x18\x03\x20\x02(\x04B\0\x12,\n\nproperties\x18\x04\x20\x03(\x0b2\x16.pu\
    lsar.proto.KeyValueB\0\x12\x19\n\x0freplicated_from\x18\x05\x20\x01(\tB\
    \0\x12\x17\n\rpartition_key\x18\x06\x20\x01(\tB\0\x12\x16\n\x0creplicate\
    _to\x18\x07\x20\x03(\tB\0\x12:\n\x0bcompression\x18\x08\x20\x01(\x0e2\
    \x1d.pulsar.proto.CompressionType:\x04NONEB\0\x12\x1e\n\x11uncompressed_\
    size\x18\t\x20\x01(\r:\x010B\0\x12\"\n\x15num_messages_in_batch\x18\x0b\
    \x20\x01(\x05:\x011B\0\x12\x17\n\nevent_time\x18\x0c\x20\x01(\x04:\x010B\
    \0\x127\n\x0fencryption_keys\x18\r\x20\x03(\x0b2\x1c.pulsar.proto.Encryp\
    tionKeysB\0\x12\x19\n\x0fencryption_algo\x18\x0e\x20\x01(\tB\0\x12\x1a\n\
    \x10encryption_param\x18\x0f\x20\x01(\x0cB\0\x12\x18\n\x0eschema_version\
    \x18\x10\x20\x01(\x0cB\0\x12*\n\x19partition_key_b64_encoded\x18\x11\x20\
    \x01(\x08:\x05falseB\0:\0\"\xdd\x01\n\x15SingleMessageMetadata\x12,\n\np\
    roperties\x18\x01\x20\x03(\x0b2\x16.pulsar.proto.KeyValueB\0\x12\x17\n\r\
    partition_key\x18\x02\x20\x01(\tB\0\x12\x16\n\x0cpayload_size\x18\x03\
    \x20\x02(\x05B\0\x12\x1e\n\rcompacted_out\x18\x04\x20\x01(\x08:\x05false\
    B\0\x12\x17\n\nevent_time\x18\x05\x20\x01(\x04:\x010B\0\x12*\n\x19partit\
    ion_key_b64_encoded\x18\x06\x20\x01(\x08:\x05falseB\0:\0\"\xa8\x02\n\x0e\
    CommandConnect\x12\x18\n\x0eclient_version\x18\x01\x20\x02(\tB\0\x12/\n\
    \x0bauth_method\x18\x02\x20\x01(\x0e2\x18.pulsar.proto.AuthMethodB\0\x12\
    \x1a\n\x10auth_method_name\x18\x05\x20\x01(\tB\0\x12\x13\n\tauth_data\
    \x18\x03\x20\x01(\x0cB\0\x12\x1d\n\x10protocol_version\x18\x04\x20\x01(\
    \x05:\x010B\0\x12\x1d\n\x13proxy_to_broker_url\x18\x06\x20\x01(\tB\0\x12\
    \x1c\n\x12original_principal\x18\x07\x20\x01(\tB\0\x12\x1c\n\x12original\
    _auth_data\x18\x08\x20\x01(\tB\0\x12\x1e\n\x14original_auth_method\x18\t\
    \x20\x01(\tB\0:\0\"M\n\x10CommandConnected\x12\x18\n\x0eserver_version\
    \x18\x01\x20\x02(\tB\0\x12\x1d\n\x10protocol_version\x18\x02\x20\x01(\
    \x05:\x010B\0:\0\"\xd0\x04\n\x10CommandSubscribe\x12\x0f\n\x05topic\x18\
    \x01\x20\x02(\tB\0\x12\x16\n\x0csubscription\x18\x02\x20\x02(\tB\0\x129\
    \n\x07subType\x18\x03\x20\x02(\x0e2&.pulsar.proto.CommandSubscribe.SubTy\
    peB\0\x12\x15\n\x0bconsumer_id\x18\x04\x20\x02(\x04B\0\x12\x14\n\nreques\
    t_id\x18\x05\x20\x02(\x04B\0\x12\x17\n\rconsumer_name\x18\x06\x20\x01(\t\
    B\0\x12\x18\n\x0epriority_level\x18\x07\x20\x01(\x05B\0\x12\x17\n\x07dur\
    able\x18\x08\x20\x01(\x08:\x04trueB\0\x127\n\x10start_message_id\x18\t\
    \x20\x01(\x0b2\x1b.pulsar.proto.MessageIdDataB\0\x12*\n\x08metadata\x18\
    \n\x20\x03(\x0b2\x16.pulsar.proto.KeyValueB\0\x12\x18\n\x0eread_compacte\
    d\x18\x0b\x20\x01(\x08B\0\x12&\n\x06schema\x18\x0c\x20\x01(\x0b2\x14.pul\
    sar.proto.SchemaB\0\x12Q\n\x0finitialPosition\x18\r\x20\x01(\x0e2..pulsa\
    r.proto.CommandSubscribe.InitialPosition:\x06LatestB\0\"4\n\x07SubType\
    \x12\r\n\tExclusive\x10\0\x12\n\n\x06Shared\x10\x01\x12\x0c\n\x08Failove\
    r\x10\x02\x1a\0\"-\n\x0fInitialPosition\x12\n\n\x06Latest\x10\0\x12\x0c\
    \n\x08Earliest\x10\x01\x1a\0:\0\"\xa6\x01\n\x1fCommandPartitionedTopicMe\
    tadata\x12\x0f\n\x05topic\x18\x01\x20\x02(\tB\0\x12\x14\n\nrequest_id\
    \x18\x02\x20\x02(\x04B\0\x12\x1c\n\x12original_principal\x18\x03\x20\x01\
    (\tB\0\x12\x1c\n\x12original_auth_data\x18\x04\x20\x01(\tB\0\x12\x1e\n\
    \x14original_auth_method\x18\x05\x20\x01(\tB\0:\0\"\x95\x02\n'CommandPar\
    titionedTopicMetadataResponse\x12\x14\n\npartitions\x18\x01\x20\x01(\rB\
    \0\x12\x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0\x12T\n\x08response\x18\
    \x03\x20\x01(\x0e2@.pulsar.proto.CommandPartitionedTopicMetadataResponse\
    .LookupTypeB\0\x12*\n\x05error\x18\x04\x20\x01(\x0e2\x19.pulsar.proto.Se\
    rverErrorB\0\x12\x11\n\x07message\x18\x05\x20\x01(\tB\0\"'\n\nLookupType\
    \x12\x0b\n\x07Success\x10\0\x12\n\n\x06Failed\x10\x01\x1a\0:\0\"\xb9\x01\
    \n\x12CommandLookupTopic\x12\x0f\n\x05topic\x18\x01\x20\x02(\tB\0\x12\
    \x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0\x12\x1e\n\rauthoritative\x18\
    \x03\x20\x01(\x08:\x05falseB\0\x12\x1c\n\x12original_principal\x18\x04\
    \x20\x01(\tB\0\x12\x1c\n\x12original_auth_data\x18\x05\x20\x01(\tB\0\x12\
    \x1e\n\x14original_auth_method\x18\x06\x20\x01(\tB\0:\0\"\xfa\x02\n\x1aC\
    ommandLookupTopicResponse\x12\x1a\n\x10brokerServiceUrl\x18\x01\x20\x01(\
    \tB\0\x12\x1d\n\x13brokerServiceUrlTls\x18\x02\x20\x01(\tB\0\x12G\n\x08r\
    esponse\x18\x03\x20\x01(\x0e23.pulsar.proto.CommandLookupTopicResponse.L\
    ookupTypeB\0\x12\x14\n\nrequest_id\x18\x04\x20\x02(\x04B\0\x12\x1e\n\rau\
    thoritative\x18\x05\x20\x01(\x08:\x05falseB\0\x12*\n\x05error\x18\x06\
    \x20\x01(\x0e2\x19.pulsar.proto.ServerErrorB\0\x12\x11\n\x07message\x18\
    \x07\x20\x01(\tB\0\x12*\n\x19proxy_through_service_url\x18\x08\x20\x01(\
    \x08:\x05falseB\0\"5\n\nLookupType\x12\x0c\n\x08Redirect\x10\0\x12\x0b\n\
    \x07Connect\x10\x01\x12\n\n\x06Failed\x10\x02\x1a\0:\0\"\xda\x01\n\x0fCo\
    mmandProducer\x12\x0f\n\x05topic\x18\x01\x20\x02(\tB\0\x12\x15\n\x0bprod\
    ucer_id\x18\x02\x20\x02(\x04B\0\x12\x14\n\nrequest_id\x18\x03\x20\x02(\
    \x04B\0\x12\x17\n\rproducer_name\x18\x04\x20\x01(\tB\0\x12\x1a\n\tencryp\
    ted\x18\x05\x20\x01(\x08:\x05falseB\0\x12*\n\x08metadata\x18\x06\x20\x03\
    (\x0b2\x16.pulsar.proto.KeyValueB\0\x12&\n\x06schema\x18\x07\x20\x01(\
    \x0b2\x14.pulsar.proto.SchemaB\0:\0\"X\n\x0bCommandSend\x12\x15\n\x0bpro\
    ducer_id\x18\x01\x20\x02(\x04B\0\x12\x15\n\x0bsequence_id\x18\x02\x20\
    \x02(\x04B\0\x12\x19\n\x0cnum_messages\x18\x03\x20\x01(\x05:\x011B\0:\0\
    \"w\n\x12CommandSendReceipt\x12\x15\n\x0bproducer_id\x18\x01\x20\x02(\
    \x04B\0\x12\x15\n\x0bsequence_id\x18\x02\x20\x02(\x04B\0\x121\n\nmessage\
    _id\x18\x03\x20\x01(\x0b2\x1b.pulsar.proto.MessageIdDataB\0:\0\"\x81\x01\
    \n\x10CommandSendError\x12\x15\n\x0bproducer_id\x18\x01\x20\x02(\x04B\0\
    \x12\x15\n\x0bsequence_id\x18\x02\x20\x02(\x04B\0\x12*\n\x05error\x18\
    \x03\x20\x02(\x0e2\x19.pulsar.proto.ServerErrorB\0\x12\x11\n\x07message\
    \x18\x04\x20\x02(\tB\0:\0\"{\n\x0eCommandMessage\x12\x15\n\x0bconsumer_i\
    d\x18\x01\x20\x02(\x04B\0\x121\n\nmessage_id\x18\x02\x20\x02(\x0b2\x1b.p\
    ulsar.proto.MessageIdDataB\0\x12\x1d\n\x10redelivery_count\x18\x03\x20\
    \x01(\r:\x010B\0:\0\"\xc7\x03\n\nCommandAck\x12\x15\n\x0bconsumer_id\x18\
    \x01\x20\x02(\x04B\0\x124\n\x08ack_type\x18\x02\x20\x02(\x0e2\x20.pulsar\
    .proto.CommandAck.AckTypeB\0\x121\n\nmessage_id\x18\x03\x20\x03(\x0b2\
    \x1b.pulsar.proto.MessageIdDataB\0\x12D\n\x10validation_error\x18\x04\
    \x20\x01(\x0e2(.pulsar.proto.CommandAck.ValidationErrorB\0\x120\n\nprope\
    rties\x18\x05\x20\x03(\x0b2\x1a.pulsar.proto.KeyLongValueB\0\"+\n\x07Ack\
    Type\x12\x0e\n\nIndividual\x10\0\x12\x0e\n\nCumulative\x10\x01\x1a\0\"\
    \x91\x01\n\x0fValidationError\x12\x1e\n\x1aUncompressedSizeCorruption\
    \x10\0\x12\x16\n\x12DecompressionError\x10\x01\x12\x14\n\x10ChecksumMism\
    atch\x10\x02\x12\x19\n\x15BatchDeSerializeError\x10\x03\x12\x13\n\x0fDec\
    ryptionError\x10\x04\x1a\0:\0\"R\n\x1bCommandActiveConsumerChange\x12\
    \x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0\x12\x1a\n\tis_active\x18\
    \x02\x20\x01(\x08:\x05falseB\0:\0\"@\n\x0bCommandFlow\x12\x15\n\x0bconsu\
    mer_id\x18\x01\x20\x02(\x04B\0\x12\x18\n\x0emessagePermits\x18\x02\x20\
    \x02(\rB\0:\0\"C\n\x12CommandUnsubscribe\x12\x15\n\x0bconsumer_id\x18\
    \x01\x20\x02(\x04B\0\x12\x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0:\0\"o\
    \n\x0bCommandSeek\x12\x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0\x12\
    \x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0\x121\n\nmessage_id\x18\x03\
    \x20\x01(\x0b2\x1b.pulsar.proto.MessageIdDataB\0:\0\"3\n\x18CommandReach\
    edEndOfTopic\x12\x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0:\0\"E\n\
    \x14CommandCloseProducer\x12\x15\n\x0bproducer_id\x18\x01\x20\x02(\x04B\
    \0\x12\x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0:\0\"E\n\x14CommandClose\
    Consumer\x12\x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0\x12\x14\n\nreq\
    uest_id\x18\x02\x20\x02(\x04B\0:\0\"u\n&CommandRedeliverUnacknowledgedMe\
    ssages\x12\x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0\x122\n\x0bmessag\
    e_ids\x18\x02\x20\x03(\x0b2\x1b.pulsar.proto.MessageIdDataB\0:\0\"P\n\
    \x0eCommandSuccess\x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04B\0\x12&\n\
    \x06schema\x18\x02\x20\x01(\x0b2\x14.pulsar.proto.SchemaB\0:\0\"\x83\x01\
    \n\x16CommandProducerSuccess\x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04B\
    \0\x12\x17\n\rproducer_name\x18\x02\x20\x02(\tB\0\x12\x1e\n\x10last_sequ\
    ence_id\x18\x03\x20\x01(\x03:\x02-1B\0\x12\x18\n\x0eschema_version\x18\
    \x04\x20\x01(\x0cB\0:\0\"e\n\x0cCommandError\x12\x14\n\nrequest_id\x18\
    \x01\x20\x02(\x04B\0\x12*\n\x05error\x18\x02\x20\x02(\x0e2\x19.pulsar.pr\
    oto.ServerErrorB\0\x12\x11\n\x07message\x18\x03\x20\x02(\tB\0:\0\"\x0f\n\
    \x0bCommandPing:\0\"\x0f\n\x0bCommandPong:\0\"E\n\x14CommandConsumerStat\
    s\x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04B\0\x12\x15\n\x0bconsumer_id\
    \x18\x04\x20\x02(\x04B\0:\0\"\xb2\x03\n\x1cCommandConsumerStatsResponse\
    \x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04B\0\x12/\n\nerror_code\x18\
    \x02\x20\x01(\x0e2\x19.pulsar.proto.ServerErrorB\0\x12\x17\n\rerror_mess\
    age\x18\x03\x20\x01(\tB\0\x12\x14\n\nmsgRateOut\x18\x04\x20\x01(\x01B\0\
    \x12\x1a\n\x10msgThroughputOut\x18\x05\x20\x01(\x01B\0\x12\x1a\n\x10msgR\
    ateRedeliver\x18\x06\x20\x01(\x01B\0\x12\x16\n\x0cconsumerName\x18\x07\
    \x20\x01(\tB\0\x12\x1a\n\x10availablePermits\x18\x08\x20\x01(\x04B\0\x12\
    \x19\n\x0funackedMessages\x18\t\x20\x01(\x04B\0\x12&\n\x1cblockedConsume\
    rOnUnackedMsgs\x18\n\x20\x01(\x08B\0\x12\x11\n\x07address\x18\x0b\x20\
    \x01(\tB\0\x12\x18\n\x0econnectedSince\x18\x0c\x20\x01(\tB\0\x12\x0e\n\
    \x04type\x18\r\x20\x01(\tB\0\x12\x18\n\x0emsgRateExpired\x18\x0e\x20\x01\
    (\x01B\0\x12\x14\n\nmsgBacklog\x18\x0f\x20\x01(\x04B\0:\0\"H\n\x17Comman\
    dGetLastMessageId\x12\x15\n\x0bconsumer_id\x18\x01\x20\x02(\x04B\0\x12\
    \x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0:\0\"q\n\x1fCommandGetLastMess\
    ageIdResponse\x126\n\x0flast_message_id\x18\x01\x20\x02(\x0b2\x1b.pulsar\
    .proto.MessageIdDataB\0\x12\x14\n\nrequest_id\x18\x02\x20\x02(\x04B\0:\0\
    \"\xcd\x01\n\x1bCommandGetTopicsOfNamespace\x12\x14\n\nrequest_id\x18\
    \x01\x20\x02(\x04B\0\x12\x13\n\tnamespace\x18\x02\x20\x02(\tB\0\x12J\n\
    \x04mode\x18\x03\x20\x01(\x0e2..pulsar.proto.CommandGetTopicsOfNamespace\
    .Mode:\nPERSISTENTB\0\"5\n\x04Mode\x12\x0e\n\nPERSISTENT\x10\0\x12\x12\n\
    \x0eNON_PERSISTENT\x10\x01\x12\x07\n\x03ALL\x10\x02\x1a\0:\0\"O\n#Comman\
    dGetTopicsOfNamespaceResponse\x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04\
    B\0\x12\x10\n\x06topics\x18\x02\x20\x03(\tB\0:\0\"U\n\x10CommandGetSchem\
    a\x12\x14\n\nrequest_id\x18\x01\x20\x02(\x04B\0\x12\x0f\n\x05topic\x18\
    \x02\x20\x02(\tB\0\x12\x18\n\x0eschema_version\x18\x03\x20\x01(\x0cB\0:\
    \0\"\xbe\x01\n\x18CommandGetSchemaResponse\x12\x14\n\nrequest_id\x18\x01\
    \x20\x02(\x04B\0\x12/\n\nerror_code\x18\x02\x20\x01(\x0e2\x19.pulsar.pro\
    to.ServerErrorB\0\x12\x17\n\rerror_message\x18\x03\x20\x01(\tB\0\x12&\n\
    \x06schema\x18\x04\x20\x01(\x0b2\x14.pulsar.proto.SchemaB\0\x12\x18\n\
    \x0eschema_version\x18\x05\x20\x01(\x0cB\0:\0\"\x88\x16\n\x0bBaseCommand\
    \x12.\n\x04type\x18\x01\x20\x02(\x0e2\x1e.pulsar.proto.BaseCommand.TypeB\
    \0\x12/\n\x07connect\x18\x02\x20\x01(\x0b2\x1c.pulsar.proto.CommandConne\
    ctB\0\x123\n\tconnected\x18\x03\x20\x01(\x0b2\x1e.pulsar.proto.CommandCo\
    nnectedB\0\x123\n\tsubscribe\x18\x04\x20\x01(\x0b2\x1e.pulsar.proto.Comm\
    andSubscribeB\0\x121\n\x08producer\x18\x05\x20\x01(\x0b2\x1d.pulsar.prot\
    o.CommandProducerB\0\x12)\n\x04send\x18\x06\x20\x01(\x0b2\x19.pulsar.pro\
    to.CommandSendB\0\x128\n\x0csend_receipt\x18\x07\x20\x01(\x0b2\x20.pulsa\
    r.proto.CommandSendReceiptB\0\x124\n\nsend_error\x18\x08\x20\x01(\x0b2\
    \x1e.pulsar.proto.CommandSendErrorB\0\x12/\n\x07message\x18\t\x20\x01(\
    \x0b2\x1c.pulsar.proto.CommandMessageB\0\x12'\n\x03ack\x18\n\x20\x01(\
    \x0b2\x18.pulsar.proto.CommandAckB\0\x12)\n\x04flow\x18\x0b\x20\x01(\x0b\
    2\x19.pulsar.proto.CommandFlowB\0\x127\n\x0bunsubscribe\x18\x0c\x20\x01(\
    \x0b2\x20.pulsar.proto.CommandUnsubscribeB\0\x12/\n\x07success\x18\r\x20\
    \x01(\x0b2\x1c.pulsar.proto.CommandSuccessB\0\x12+\n\x05error\x18\x0e\
    \x20\x01(\x0b2\x1a.pulsar.proto.CommandErrorB\0\x12<\n\x0eclose_producer\
    \x18\x0f\x20\x01(\x0b2\".pulsar.proto.CommandCloseProducerB\0\x12<\n\x0e\
    close_consumer\x18\x10\x20\x01(\x0b2\".pulsar.proto.CommandCloseConsumer\
    B\0\x12@\n\x10producer_success\x18\x11\x20\x01(\x0b2$.pulsar.proto.Comma\
    ndProducerSuccessB\0\x12)\n\x04ping\x18\x12\x20\x01(\x0b2\x19.pulsar.pro\
    to.CommandPingB\0\x12)\n\x04pong\x18\x13\x20\x01(\x0b2\x19.pulsar.proto.\
    CommandPongB\0\x12_\n\x1fredeliverUnacknowledgedMessages\x18\x14\x20\x01\
    (\x0b24.pulsar.proto.CommandRedeliverUnacknowledgedMessagesB\0\x12J\n\
    \x11partitionMetadata\x18\x15\x20\x01(\x0b2-.pulsar.proto.CommandPartiti\
    onedTopicMetadataB\0\x12Z\n\x19partitionMetadataResponse\x18\x16\x20\x01\
    (\x0b25.pulsar.proto.CommandPartitionedTopicMetadataResponseB\0\x127\n\
    \x0blookupTopic\x18\x17\x20\x01(\x0b2\x20.pulsar.proto.CommandLookupTopi\
    cB\0\x12G\n\x13lookupTopicResponse\x18\x18\x20\x01(\x0b2(.pulsar.proto.C\
    ommandLookupTopicResponseB\0\x12;\n\rconsumerStats\x18\x19\x20\x01(\x0b2\
    \".pulsar.proto.CommandConsumerStatsB\0\x12K\n\x15consumerStatsResponse\
    \x18\x1a\x20\x01(\x0b2*.pulsar.proto.CommandConsumerStatsResponseB\0\x12\
    C\n\x11reachedEndOfTopic\x18\x1b\x20\x01(\x0b2&.pulsar.proto.CommandReac\
    hedEndOfTopicB\0\x12)\n\x04seek\x18\x1c\x20\x01(\x0b2\x19.pulsar.proto.C\
    ommandSeekB\0\x12A\n\x10getLastMessageId\x18\x1d\x20\x01(\x0b2%.pulsar.p\
    roto.CommandGetLastMessageIdB\0\x12Q\n\x18getLastMessageIdResponse\x18\
    \x1e\x20\x01(\x0b2-.pulsar.proto.CommandGetLastMessageIdResponseB\0\x12K\
    \n\x16active_consumer_change\x18\x1f\x20\x01(\x0b2).pulsar.proto.Command\
    ActiveConsumerChangeB\0\x12I\n\x14getTopicsOfNamespace\x18\x20\x20\x01(\
    \x0b2).pulsar.proto.CommandGetTopicsOfNamespaceB\0\x12Y\n\x1cgetTopicsOf\
    NamespaceResponse\x18!\x20\x01(\x0b21.pulsar.proto.CommandGetTopicsOfNam\
    espaceResponseB\0\x123\n\tgetSchema\x18\"\x20\x01(\x0b2\x1e.pulsar.proto\
    .CommandGetSchemaB\0\x12C\n\x11getSchemaResponse\x18#\x20\x01(\x0b2&.pul\
    sar.proto.CommandGetSchemaResponseB\0\"\xa5\x05\n\x04Type\x12\x0b\n\x07C\
    ONNECT\x10\x02\x12\r\n\tCONNECTED\x10\x03\x12\r\n\tSUBSCRIBE\x10\x04\x12\
    \x0c\n\x08PRODUCER\x10\x05\x12\x08\n\x04SEND\x10\x06\x12\x10\n\x0cSEND_R\
    ECEIPT\x10\x07\x12\x0e\n\nSEND_ERROR\x10\x08\x12\x0b\n\x07MESSAGE\x10\t\
    \x12\x07\n\x03ACK\x10\n\x12\x08\n\x04FLOW\x10\x0b\x12\x0f\n\x0bUNSUBSCRI\
    BE\x10\x0c\x12\x0b\n\x07SUCCESS\x10\r\x12\t\n\x05ERROR\x10\x0e\x12\x12\n\
    \x0eCLOSE_PRODUCER\x10\x0f\x12\x12\n\x0eCLOSE_CONSUMER\x10\x10\x12\x14\n\
    \x10PRODUCER_SUCCESS\x10\x11\x12\x08\n\x04PING\x10\x12\x12\x08\n\x04PONG\
    \x10\x13\x12%\n!REDELIVER_UNACKNOWLEDGED_MESSAGES\x10\x14\x12\x18\n\x14P\
    ARTITIONED_METADATA\x10\x15\x12!\n\x1dPARTITIONED_METADATA_RESPONSE\x10\
    \x16\x12\n\n\x06LOOKUP\x10\x17\x12\x13\n\x0fLOOKUP_RESPONSE\x10\x18\x12\
    \x12\n\x0eCONSUMER_STATS\x10\x19\x12\x1b\n\x17CONSUMER_STATS_RESPONSE\
    \x10\x1a\x12\x18\n\x14REACHED_END_OF_TOPIC\x10\x1b\x12\x08\n\x04SEEK\x10\
    \x1c\x12\x17\n\x13GET_LAST_MESSAGE_ID\x10\x1d\x12\x20\n\x1cGET_LAST_MESS\
    AGE_ID_RESPONSE\x10\x1e\x12\x1a\n\x16ACTIVE_CONSUMER_CHANGE\x10\x1f\x12\
    \x1b\n\x17GET_TOPICS_OF_NAMESPACE\x10\x20\x12$\n\x20GET_TOPICS_OF_NAMESP\
    ACE_RESPONSE\x10!\x12\x0e\n\nGET_SCHEMA\x10\"\x12\x17\n\x13GET_SCHEMA_RE\
    SPONSE\x10#\x1a\0:\0*:\n\x0fCompressionType\x12\x08\n\x04NONE\x10\0\x12\
    \x07\n\x03LZ4\x10\x01\x12\x08\n\x04ZLIB\x10\x02\x12\x08\n\x04ZSTD\x10\
    \x03\x1a\0*\xd6\x03\n\x0bServerError\x12\x10\n\x0cUnknownError\x10\0\x12\
    \x11\n\rMetadataError\x10\x01\x12\x14\n\x10PersistenceError\x10\x02\x12\
    \x17\n\x13AuthenticationError\x10\x03\x12\x16\n\x12AuthorizationError\
    \x10\x04\x12\x10\n\x0cConsumerBusy\x10\x05\x12\x13\n\x0fServiceNotReady\
    \x10\x06\x12%\n!ProducerBlockedQuotaExceededError\x10\x07\x12)\n%Produce\
    rBlockedQuotaExceededException\x10\x08\x12\x11\n\rChecksumError\x10\t\
    \x12\x1b\n\x17UnsupportedVersionError\x10\n\x12\x11\n\rTopicNotFound\x10\
    \x0b\x12\x18\n\x14SubscriptionNotFound\x10\x0c\x12\x14\n\x10ConsumerNotF\
    ound\x10\r\x12\x13\n\x0fTooManyRequests\x10\x0e\x12\x18\n\x14TopicTermin\
    atedError\x10\x0f\x12\x10\n\x0cProducerBusy\x10\x10\x12\x14\n\x10Invalid\
    TopicName\x10\x11\x12\x16\n\x12IncompatibleSchema\x10\x12\x1a\0*M\n\nAut\
    hMethod\x12\x12\n\x0eAuthMethodNone\x10\0\x12\x13\n\x0fAuthMethodYcaV1\
    \x10\x01\x12\x14\n\x10AuthMethodAthens\x10\x02\x1a\0*\x87\x01\n\x0fProto\
    colVersion\x12\x06\n\x02v0\x10\0\x12\x06\n\x02v1\x10\x01\x12\x06\n\x02v2\
    \x10\x02\x12\x06\n\x02v3\x10\x03\x12\x06\n\x02v4\x10\x04\x12\x06\n\x02v5\
    \x10\x05\x12\x06\n\x02v6\x10\x06\x12\x06\n\x02v7\x10\x07\x12\x06\n\x02v8\
    \x10\x08\x12\x06\n\x02v9\x10\t\x12\x07\n\x03v10\x10\n\x12\x07\n\x03v11\
    \x10\x0b\x12\x07\n\x03v12\x10\x0c\x12\x07\n\x03v13\x10\r\x1a\0B\0b\x06pr\
    oto2\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
